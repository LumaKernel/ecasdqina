<!DOCTYPE html>
<html lang="ja"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>one | るまライブラリ</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="one" />
<meta name="author" content="luma" />
<meta property="og:locale" content="ja" />
<meta name="description" content="ぼくが競プロで使うライブラリです．" />
<meta property="og:description" content="ぼくが競プロで使うライブラリです．" />
<link rel="canonical" href="http://localhost:4000/ecasdqina/one" />
<meta property="og:url" content="http://localhost:4000/ecasdqina/one" />
<meta property="og:site_name" content="るまライブラリ" />
<script type="application/ld+json">
{"headline":"one","@type":"WebPage","url":"http://localhost:4000/ecasdqina/one","author":{"@type":"Person","name":"luma"},"description":"ぼくが競プロで使うライブラリです．","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.11.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/combine/npm/katex@0.10.0-rc/dist/katex.min.js,npm/katex@0.10.0-rc/dist/contrib/auto-render.min.js"></script>
  <script defer>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
          delimiters: [
            { left: "$$", right: "$$", display: true },
            { left: "\\[", right: "\\]", display: true },
            { left: "$", right: "$", display: false },
          ]
        });
      });
  </script>
<link rel="stylesheet" href="/ecasdqina/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/ecasdqina/feed.xml" title="るまライブラリ" /></head>
<style>
    hr {
      page-break-after: always;
    }
  </style>

  <body>
    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <p><span class="lib-title">FastZetaTransform</span></p>

<pre><code>// a'[i] = sum(j は i を含む, a[j])
template &lt; class T &gt;
void zeta(vector&lt; T &gt; &amp;a,
          function&lt; T(T, T) &gt; const &amp;op = [](T a, T b) { return a + b; }) {
  int n = a.size();
  for(int i = 0; i &lt; n; i++)
    for(int b = 0; b &lt; (1 &lt;&lt; n); b++)
      if(!(b &amp; (1 &lt;&lt; i))) a[b] = op(a[b], a[b | (1 &lt;&lt; i)]);
}
</code></pre>

<p><span class="lib-title">FastMoebiusTransform</span></p>

<pre><code>// zetaの逆操作
template &lt; class T &gt;
void moebius(vector&lt; T &gt; &amp;a,
             function&lt; T(T, T) &gt; const &amp;op = [](T a, T b) { return a - b; }) {
  int n = a.size();
  for(int i = 0; i &lt; n; i++)
    for(int b = 0; b &lt; (1 &lt;&lt; n); b++)
      if(b &amp; (1 &lt;&lt; i)) a[b] = op(a[b], a[b | (1 &lt;&lt; i)]);
}
</code></pre>

<p><span class="lib-title">Garner Library</span></p>

<pre><code>/// --- Garner Library {{{ ///
ll garner(vector&lt; int &gt; n, vector&lt; int &gt; mods, ll mod) {
  n.emplace_back(0);
  mods.emplace_back(mod);
  vector&lt; ll &gt; coeffs(n.size(), 1); // v_i の係数
  // v_i の項より後ろの項の和,答え mod mods[i]
  vector&lt; ll &gt; constants(n.size(), 0);
  for(size_t i = 0; i &lt; n.size(); i++) {
    // coeffs[i] * v_i + constants[i] == n[i] (mod mods[i]) を解く
    ll v = ll(n[i] - constants[i]) * modinv(coeffs[i], mods[i]) % mods[i];
    if(v &lt; 0) v += mods[i];
    for(size_t j = i + 1; j &lt; n.size(); j++) {
      // coeffs[j] is (mod j)
      (constants[j] += coeffs[j] * v) %= mods[j];
      (coeffs[j] *= mods[i]) %= mods[j];
    }
  }
  return constants.back();
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">Hu-Tucker Algorithm Library</span></p>

<pre><code>// calculate value of optimal alphabetic binary search tree
// if you want to construct? you can do it!
/// --- Hu-Tucker Algorithm Library {{{ ///
template &lt; class Heap, class T = ll &gt;
T HuTucker(const vector&lt; T &gt; &amp;w) {
  using P = pair&lt; T, int &gt;; // value, index
  int n = w.size();
  function&lt; T(Heap * &amp;a) &gt; calc = [](Heap *&amp;a) { ////
    return a-&gt;val.first + second(a)-&gt;val.first;
  };
  vector&lt; int &gt; rig(n), lef(n);
  vector&lt; int &gt; removed(n), used(n);
  vector&lt; Heap * &gt; dat(n);
  function&lt; bool(int) &gt; isAvailable = [&amp;](int idx) {
    if(idx &lt; 0) return true;
    if(idx &gt;= n) idx -= n; /////
    return !used[idx];
  };
  function&lt; void(Heap *&amp;, int, int) &gt; check = [&amp;](Heap *&amp;top, int gid,
                                                  int idx) {
    if(idx &lt; 0) return;
    if(idx &lt; n) {
      used[idx] = 1;
      if(lef[gid] &gt;= 0) {
        top = meld(top, dat[lef[gid]]);
        removed[lef[gid]] = 1;
        lef[gid] = lef[lef[gid]];
        if(lef[gid] &gt;= 0) rig[lef[gid]] = gid; ///
      }
    } else {
      used[idx - n] = 1;
      if(rig[gid] &lt; n - 1) {
        top = meld(top, dat[rig[gid]]);
        removed[rig[gid]] = 1;
        rig[gid] = rig[rig[gid]];
        if(rig[gid] &lt; n - 1) lef[rig[gid]] = gid; ///
      }
    }
  };
  priority_queue&lt; P, vector&lt; P &gt;, greater&lt; P &gt; &gt; pq; ///
  for(int i = 0; i &lt; n - 1; i++) {
    auto *a = new Heap(P(w[i], i)), *b = new Heap(P(w[i + 1], i + 1 + n));
    dat[i] = meld(a, b);
    pq.emplace(calc(dat[i]), i); ///
    lef[i] = i - 1;
    rig[i] = i + 1;
  }
  ll ans = 0;
  while(pq.size()) {
    int i = pq.top().second;
    auto top = dat[i];
    pq.pop();
    if(removed[i]) continue;
    P p0 = top-&gt;val;
    P p1 = second(top)-&gt;val;
    pop(top);
    pop(top);
    bool c0 = isAvailable(p0.second);
    bool c1 = isAvailable(p1.second);
    if(!c0 || !c1) {
      if(c0) push(top, p0);
      if(c1) push(top, p1);
      dat[i] = top;
      if(top != nullptr &amp;&amp; top-&gt;l != nullptr) {
        pq.emplace(calc(top), i); ///
      }
      continue;
    }
    T nval = p0.first + p1.first;
    ans += nval;
    check(top, i, p0.second);
    check(top, i, p1.second);
    if(top != nullptr) {
      push(top, P(nval, -1));
      dat[i] = top;
      pq.emplace(calc(top), i); ///
    }
  }
  return ans;
}
/// }}}--- ///

// usage :
// HuTucker&lt; SkewHeap&lt; pair&lt;ll, int&gt; &gt; &gt;(w)
</code></pre>

<p><span class="lib-title">Kitamasa Library</span></p>

<pre><code>template &lt; class T &gt;
vector&lt; T &gt; kitamasa(const vector&lt; T &gt; &amp;c, const vector&lt; T &gt; &amp;u,
                     const vector&lt; T &gt; &amp;v) {
  int k = c.size();
  vector&lt; T &gt; r(2 * k - 1);
  for(int i = 0; i &lt; k; i++)
    for(int j = 0; j &lt; k; j++) r[i + j] += u[i] * v[j];
  for(int i = 2 * k - 2; i &gt;= k; i--)
    for(int j = 0; j &lt; k; j++) r[i - k + j] += r[i] * c[j];
  r.resize(k);
  return r;
}
</code></pre>

<p><span class="lib-title">MoTreeVertex Library</span></p>

<pre><code>// MoTreeVertex(N, JUST Q, double k)
// favored : k = 2
// 1: addEdge
// 2: prebuild
// 3: insert
// 4: build
/// --- MoTreeVertex Library {{{ ///

struct MoTreeVertex {
  const int n, logn, m;
  const int width;
  int q = 0;
  vector&lt; vector&lt; int &gt; &gt; par;
  vector&lt; int &gt; dep;
  vector&lt; int &gt; in, vs;
  vector&lt; vector&lt; int &gt; &gt; g;
  vector&lt; int8_t &gt; flag;
  vector&lt; int &gt; le, ri, lcas, order;
  int nl = 0, nr = 0;
  int log(int x) {
    int h = 1;
    while((1 &lt;&lt; h) &lt; x) h++;
    return h;
  }
  MoTreeVertex(int n, int q, double k = 1)
      : n(n),
        logn(log(n)),
        m(2 * n - 1),
        width(int(k* m / sqrt(q) + 1.0)),
        q(q),
        par(logn, vector&lt; int &gt;(n, -1)),
        dep(n),
        in(n),
        g(n),
        flag(n),
        le(q),
        ri(q),
        lcas(q),
        order(q) {
    vs.reserve(m);
  }
  inline void addEdge(int u, int v) {
    g[u].emplace_back(v);
    g[v].emplace_back(u);
  }
  inline void prebuild() {
    dfs(0, -1, 0);
    for(int k = 1; k &lt; logn; k++)
      for(int i = 0; i &lt; n; i++) {
        int p = par[k - 1][i];
        if(p == -1) continue;
        par[k][i] = par[k - 1][p];
      }
  }
  void dfs(int i, int p, int d) {
    dep[i] = d;
    par[0][i] = p;
    in[i] = vs.size();
    vs.emplace_back(i);
    for(int j : g[i])
      if(j != p) {
        dfs(j, i, d + 1);
        vs.emplace_back(j);
      }
  }
  inline int lca(int u, int v) {
    if(dep[u] &gt; dep[v]) swap(u, v);
    for(int k = logn - 1; k &gt;= 0; k--) {
      int nv = par[k][v];
      if(nv != -1 &amp;&amp; dep[nv] &gt;= dep[u]) v = nv;
    }
    if(u == v) return u;
    for(int k = logn - 1; k &gt;= 0; k--) {
      int nu = par[k][u], nv = par[k][v];
      if(nu != nv) u = nu, v = nv;
    }
    return par[0][u];
  }
  inline void insert(int u, int v) {
    if(in[u] &gt; in[v]) swap(u, v);
    le[q] = in[u] + 1;
    ri[q] = in[v] + 1;
    lcas[q] = lca(u, v);
    order[q] = q;
    q++;
  }
  inline void build() {
    sort(begin(order), begin(order) + q, [&amp;](int a, int b) {
      const int ab = le[a] / width, bb = le[b] / width;
      return ab != bb ? ab &lt; bb : ab &amp; 1 ? ri[a] &lt; ri[b] : ri[b] &lt; ri[a];
    });
    nl = nr = le[order[0]];
    for(int i = 0; i &lt; q; i++) {
      if(i &gt; 0) rem(lcas[order[i - 1]]);
      const int id = order[i];
      while(nl &gt; le[id]) flip(vs[--nl]);
      while(nr &lt; ri[id]) flip(vs[nr++]);
      while(nl &lt; le[id]) flip(vs[nl++]);
      while(nr &gt; ri[id]) flip(vs[--nr]);
      add(lcas[id]);
      next(id);
    }
  }
  inline void flip(int i) {
    if(flag[i] ^= 1)
      add(i);
    else
      rem(i);
  }
  inline void next(int id);
  inline void add(int i);
  inline void rem(int i);
};

/// }}}--- ///

inline void MoTreeVertex::next(int id) {}
inline void MoTreeVertex::add(int i) {}
inline void MoTreeVertex::rem(int i) {}
</code></pre>

<p><span class="lib-title">Mo Library</span></p>

<pre><code>// Mo(N, JUST Q, double k)
// favored : k = 2
// 1: insert
// 2: build
/// --- Mo Library {{{ ///

struct Mo {
  const int width;
  int q = 0;
  vector&lt; int &gt; le, ri, order;
  int nl = 0, nr = 0;
  Mo(int n, int q, double k = 1)
      : width(int(k* n / sqrt(q) + 1.0)), le(q), ri(q), order(q) {}
  inline void insert(int l, int r) {
    le[q] = l;
    ri[q] = r;
    order[q] = q;
    q++;
  }
  inline void build() {
    sort(begin(order), begin(order) + q, [&amp;](int a, int b) {
      const int ab = le[a] / width, bb = le[b] / width;
      return ab != bb ? ab &lt; bb : ab &amp; 1 ? ri[a] &lt; ri[b] : ri[b] &lt; ri[a];
    });
    nl = nr = le[order[0]];
    for(int i = 0; i &lt; q; i++) {
      const int id = order[i];
      while(nl &gt; le[id]) add(--nl);
      while(nl &lt; le[id]) rem(nl++);
      while(nr &lt; ri[id]) add(nr++);
      while(nr &gt; ri[id]) rem(--nr);
      next(id);
    }
  }
  inline void next(int i);
  inline void add(int i);
  inline void rem(int i);
};

/// }}}--- ///

inline void Mo::next(int i) {}
inline void Mo::add(int i) {}
inline void Mo::rem(int i) {}
</code></pre>

<p><span class="lib-title">Mo3D Library</span></p>

<pre><code>// Mo3D(N, JUST Q, double k)
// favored : k = 6
// 1: insert
// 2: build
/// --- Mo3D Library {{{ ///

struct Mo3D {
  const int width;
  int q = 0;
  vector&lt; int &gt; le, ri, idx, order;
  int nl = 0, nr = 0, time = -1;
  Mo3D(int n, int q, double k = 1)
      : width(int(k* pow(max(n, q), 2.0 / 3.0) + 1.0)),
        le(q),
        ri(q),
        idx(q),
        order(q) {}
  inline void insert(int t, int l, int r) {
    idx[q] = t;
    le[q] = l;
    ri[q] = r;
    order[q] = q;
    q++;
  }
  inline void build() {
    sort(begin(order), begin(order) + q, [&amp;](int a, int b) {
      const int al = le[a] / width, bl = le[b] / width;
      const int ar = ri[a] / width, br = ri[b] / width;
      return al != bl ? al &lt; bl : ar != br ? ar &lt; br : idx[a] &lt; idx[b];
    });
    nl = nr = le[order[0]];
    for(int i = 0; i &lt; q; i++) {
      const int id = order[i];
      while(time &lt; idx[id]) addQuery(++time);
      while(time &gt; idx[id]) remQuery(time--);
      while(nl &gt; le[id]) add(--nl);
      while(nr &lt; ri[id]) add(nr++);
      while(nl &lt; le[id]) rem(nl++);
      while(nr &gt; ri[id]) rem(--nr);
      next(id);
    }
  }
  inline void next(int i);
  inline void addQuery(int i);
  inline void remQuery(int i);
  inline void add(int i);
  inline void rem(int i);
};

/// }}}--- ///

// i is sequential
// idx[i] is absolute
inline void Mo3D::next(int i) {}
inline void Mo3D::addQuery(int i) {}
inline void Mo3D::remQuery(int i) {}
inline void Mo3D::add(int i) {}
inline void Mo3D::rem(int i) {}
</code></pre>

<p><span class="lib-title">MoEx UF example</span></p>

<pre><code>const int N = 1e5;

int par[N * 2];
int col = 1;
int used[N * 2];
int ans[N];
using P = pair&lt; int, int &gt;;
vector&lt; P &gt; history;

void reset(int i) {
  if(used[i] != col) used[i] = col, par[i] = -1;
}
int find(int a) {
  reset(a);
  return par[a] &lt; 0 ? a : find(par[a]);
}
bool same(int a, int b) { return find(a) == find(b); }
void unite(int a, int b) {
  a = find(a), b = find(b);
  if(a == b) return;
  if(par[a] &lt; par[b]) swap(a, b);
  history.emplace_back(b, par[b]);
  history.emplace_back(a, par[a]);
  par[b] += par[a];
  par[a] = b;
}

inline void MoEx::next(int id) { ans[id]; /* */ }
inline void MoEx::init() {
  //
  history.clear();
  col++;
}
inline void MoEx::snapshot() {
  oldNow = now;
  history.clear();
}
inline void MoEx::rollback() {
  now = oldNow;
  while(history.size()) {
    int i, x;
    tie(i, x) = history.back();
    par[i] = x;
    history.pop_back();
  }
}
inline void MoEx::add(int i) {
  unite(a[i] + N, b[i]);
  unite(a[i], b[i] + N);
  //
}
</code></pre>

<p><span class="lib-title">Mo with Persistent Data Structure Library</span></p>

<pre><code>// MoEx(N, JUST Q, double k)
// favored : k = 2
// 1: insert
// 2: build
/// --- Mo with Persistent Data Structure Library {{{ ///

struct MoEx {
  const int width;
  int q = 0;
  vector&lt; int &gt; le, ri, order;
  MoEx(int n, int q, double k = 1)
      : width(int(k* n / sqrt(q) + 1.0)), le(q), ri(q), order(q) {}
  inline void insert(int l, int r) {
    le[q] = l;
    ri[q] = r;
    order[q] = q;
    q++;
  }
  inline void build() {
    for(int i = 0; i &lt; q; i++)
      if(ri[i] - le[i] &lt; width) {
        init();
        for(int j = le[i]; j &lt; ri[i]; j++) add(j);
        next(i);
      }
    sort(begin(order), begin(order) + q, [&amp;](int a, int b) {
      const int ab = le[a] / width, bb = le[b] / width;
      return ab != bb ? ab &lt; bb : ri[a] &lt; ri[b];
    });
    int last = -1;
    int nr;
    for(int i = 0; i &lt; q; i++) {
      int id = order[i];
      if(ri[id] - le[id] &lt; width) continue;
      int b = le[id] / width;
      if(last != b) init(), nr = (b + 1) * width;
      last = b;
      while(nr &lt; ri[id]) add(nr++);
      snapshot();
      for(int j = (b + 1) * width - 1; j &gt;= le[id]; j--) add(j);
      next(id);
      rollback();
    }
  }
  inline void next(int id);
  inline void init();
  inline void snapshot();
  inline void rollback();
  inline void add(int i);
};

/// }}}--- ///

inline void MoEx::next(int id) {}
inline void MoEx::init() {}
inline void MoEx::snapshot() {}
inline void MoEx::rollback() {}
inline void MoEx::add(int i) {}
</code></pre>

<p><span class="lib-title">RBST Sequence Library</span></p>

<pre><code>/// --- RBST Sequence Library {{{ ///

template &lt; class Monoid, class M_act &gt;
struct RBSTSeq {
private:
  using u32 = uint32_t;
  using X = typename Monoid::T;
  using M = typename M_act::M;
  RBSTSeq *l = nullptr, *r = nullptr;
  X val;
  X accum = Monoid::identity();
  M lazy = M_act::identity();
  bool rev = false;
  int sz = 1;
  // call after touch its child
  // a is not nullptr and is evaled, its child is proped
  friend RBSTSeq *prop(RBSTSeq *a) {
    a-&gt;sz = size(a-&gt;l) + 1 + size(a-&gt;r);
    a-&gt;accum =
        Monoid::op(Monoid::op(Accumulated(a-&gt;l), a-&gt;val), Accumulated(a-&gt;r));
    return a;
  }
  // call before use val, accum
  friend void eval(RBSTSeq *a) {
    if(a-&gt;lazy != M_act::identity()) {
      a-&gt;val = M_act::actInto(a-&gt;lazy, -1, 1, a-&gt;val);
      a-&gt;accum = M_act::actInto(a-&gt;lazy, -1, a-&gt;sz, a-&gt;accum);
      if(a-&gt;l != nullptr) a-&gt;l-&gt;lazy = M_act::op(a-&gt;lazy, a-&gt;l-&gt;lazy);
      if(a-&gt;r != nullptr) a-&gt;r-&gt;lazy = M_act::op(a-&gt;lazy, a-&gt;r-&gt;lazy);
      a-&gt;lazy = M_act::identity();
    }
    if(a-&gt;rev) {
      swap(a-&gt;l, a-&gt;r);
      if(a-&gt;l != nullptr) a-&gt;l-&gt;rev ^= 1;
      if(a-&gt;r != nullptr) a-&gt;r-&gt;rev ^= 1;
      a-&gt;rev = false;
    }
  }
  friend X Accumulated(RBSTSeq *a) {
    return a == nullptr ? Monoid::identity() : (eval(a), a-&gt;accum);
  }
  /// --- XorShift128 {{{ ///
  struct XorShift128 {
    using u32 = uint32_t;
    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;
    XorShift128(u32 seed = 0) { z ^= seed; }
    u32 operator()() {
      u32 t = x ^ (x &lt;&lt; 11);
      x = y, y = z, z = w;
      return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
    }
  };
  /// }}}--- ///
public:
  RBSTSeq(X val = Monoid::identity()) : val(val) {}
  friend RBSTSeq *merge(RBSTSeq *a, RBSTSeq *b) {
    static XorShift128 xs(__LINE__ * 3 + 5);
    if(a == nullptr) return b;
    if(b == nullptr) return a;
    eval(a);
    eval(b);
    if(xs() % (size(a) + size(b)) &lt; (u32) size(a)) {
      a-&gt;r = merge(a-&gt;r, b);
      return prop(a);
    } else {
      b-&gt;l = merge(a, b-&gt;l);
      return prop(b);
    }
  }
  friend int size(RBSTSeq *a) { return a == nullptr ? 0 : a-&gt;sz; }
  using PNN = pair&lt; RBSTSeq *, RBSTSeq * &gt;;
  // [0, k), [k, n)
  // 左のグループにk個いれる
  friend PNN split(RBSTSeq *a, int k) {
    if(a == nullptr) return PNN(nullptr, nullptr);
    eval(a);
    RBSTSeq *sl, *sr;
    if(k &lt;= size(a-&gt;l)) {
      tie(sl, sr) = split(a-&gt;l, k);
      a-&gt;l = sr;
      return PNN(sl, prop(a));
    } else {
      tie(sl, sr) = split(a-&gt;r, k - size(a-&gt;l) - 1);
      a-&gt;r = sl;
      return PNN(prop(a), sr);
    }
  }
  friend void insert(RBSTSeq *&amp;a, int k, const X &amp;x) {
    RBSTSeq *sl, *sr;
    tie(sl, sr) = split(a, k);
    a = merge(sl, merge(new RBSTSeq(x), sr));
  }
  friend X erase(RBSTSeq *&amp;a, int k) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, k + 1);
    tie(tl, tr) = split(sl, k);
    a = merge(tl, sr);
    return tr-&gt;val;
  }
  friend void erase(RBSTSeq *&amp;a, int l, int r) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    a = merge(tl, sr);
  }
  friend void set1(RBSTSeq *&amp;a, int k, X const &amp;x) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, k + 1);
    tie(tl, tr) = split(sl, k);
    if(tr != nullptr) tr-&gt;val = tr-&gt;accum = x;
    a = merge(merge(tl, tr), sr);
  }
  friend X get(RBSTSeq *&amp;a, int k) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, k + 1);
    tie(tl, tr) = split(sl, k);
    X res = tr == nullptr ? Monoid::identity() : tr-&gt;val;
    a = merge(merge(tl, tr), sr);
    return res;
  }
  friend void act(RBSTSeq *&amp;a, int l, int r, M const &amp;m) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    if(tr != nullptr) tr-&gt;lazy = M_act::op(m, tr-&gt;lazy);
    a = merge(merge(tl, tr), sr);
  }
  friend X query(RBSTSeq *&amp;a, int l, int r) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    X res = tr == nullptr ? Monoid::identity() : tr-&gt;accum;
    a = merge(merge(tl, tr), sr);
    return res;
  }
  friend void reverse(RBSTSeq *&amp;a, int l, int r) {
    RBSTSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    if(tr != nullptr) tr-&gt;rev ^= 1;
    a = merge(merge(tl, tr), sr);
  }
};

/// }}}--- ///

/// --- Monoid, M_act examples {{{ ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

// MinAdd m + x
// MinSet m
// SumAdd m * n + x
// SumSet m * n

struct RangeMinAdd {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll, const X &amp;x) { return m + x; }
};

struct RangeMinSet {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll, const X &amp;) { return m; }
};

struct RangeSumAdd {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;x) { return m * n + x; }
};

struct RangeSumSet {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;) { return m * n; }
};

/// }}}--- ///

RBSTSeq&lt; RangeMin, RangeMinAdd &gt; *seq = nullptr;
</code></pre>

<p><span class="lib-title">RBST Multiset Library</span></p>

<pre><code>/// --- RBST Multiset Library {{{ ///

template &lt; class Key &gt;
struct RBSTMultiset {
public:
  const Key key;

private:
  using u32 = uint32_t;
  using PNN = pair&lt; RBSTMultiset*, RBSTMultiset* &gt;;
  RBSTMultiset *l = nullptr, *r = nullptr;
  int sz = 1;
  friend RBSTMultiset* prop(RBSTMultiset* a) {
    a-&gt;sz = size(a-&gt;l) + 1 + size(a-&gt;r);
    return a;
  }
  /// --- XorShift128 {{{ ///
  struct XorShift128 {
    using u32 = uint32_t;
    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;
    XorShift128(u32 seed = 0) { z ^= seed; }
    u32 operator()() {
      u32 t = x ^ (x &lt;&lt; 11);
      x = y, y = z, z = w;
      return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
    }
  };
  /// }}}--- ///
public:
  RBSTMultiset(Key key) : key(key) {}
  friend RBSTMultiset* merge(RBSTMultiset* a, RBSTMultiset* b) {
    static XorShift128 xs(__LINE__ * 3 + 5);
    if(a == nullptr) return b;
    if(b == nullptr) return a;
    if(xs() % (size(a) + size(b)) &lt; (u32) size(a)) {
      a-&gt;r = merge(a-&gt;r, b);
      return prop(a);
    } else {
      b-&gt;l = merge(a, b-&gt;l);
      return prop(b);
    }
  }
  // lower (-inf, key), [key, inf)
  // upper (-inf, key], (key, inf)
  friend PNN split(RBSTMultiset* a, Key key, bool upper) {
    if(a == nullptr) return PNN(nullptr, nullptr);
    RBSTMultiset *sl, *sr;
    if(upper ? key &lt; a-&gt;key : !(a-&gt;key &lt; key)) {
      tie(sl, sr) = split(a-&gt;l, key, upper);
      a-&gt;l = sr;
      return PNN(sl, prop(a));
    } else {
      tie(sl, sr) = split(a-&gt;r, key, upper);
      a-&gt;r = sl;
      return PNN(prop(a), sr);
    }
  }
  friend PNN lower_split(RBSTMultiset* a, const Key&amp; key) {
    return split(a, key, false);
  }
  friend PNN upper_split(RBSTMultiset* a, const Key&amp; key) {
    return split(a, key, true);
  }
  friend int size(RBSTMultiset* a) { return a == nullptr ? 0 : a-&gt;sz; }
  friend void insert(RBSTMultiset*&amp; a, Key key) {
    RBSTMultiset *sl, *sr;
    tie(sl, sr) = lower_split(a, key);
    a = merge(sl, merge(new RBSTMultiset(key), sr));
  }
  friend void erase(RBSTMultiset*&amp; a, Key key) {
    RBSTMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = upper_split(a, key);
    tie(tl, tr) = lower_split(sl, key);
    a = merge(tl, sr);
  }
  friend void erase(RBSTMultiset*&amp; a, Key keyL, Key keyR,
                    bool inclusive = false) {
    RBSTMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, keyR, inclusive);
    tie(tl, tr) = lower_split(sl, keyL);
    a = merge(tl, sr);
  }
  friend void erase1(RBSTMultiset*&amp; a, Key key) {
    if(a == nullptr) return;
    if(key &lt; a-&gt;key) {
      erase1(a-&gt;l, key);
    } else {
      if(!(a-&gt;key &lt; key)) {
        a = merge(a-&gt;l, a-&gt;r);
        return;
      }
      erase1(a-&gt;r, key);
    }
    prop(a);
  }
  friend Key getKth(RBSTMultiset*&amp; a, int k) {
    static const struct CannotGetKthOfNullptr {} ex;
    if(a == nullptr) throw ex;
    if(k &lt;= size(a-&gt;l)) {
      if(k == size(a-&gt;l)) return a-&gt;key;
      return getKth(a-&gt;l, k);
    } else {
      return getKth(a-&gt;r, k - size(a-&gt;l) - 1);
    }
  }
  friend int count(RBSTMultiset*&amp; a, Key key) {
    RBSTMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = upper_split(a, key);
    tie(tl, tr) = lower_split(sl, key);
    int cnt = size(tr);
    a = merge(merge(tl, tr), sr);
    return cnt;
  }
  friend int count(RBSTMultiset*&amp; a, Key keyL, Key keyR,
                   bool inclusive = false) {
    RBSTMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, keyR, inclusive);
    tie(tl, tr) = lower_split(sl, keyL);
    int cnt = size(tr);
    a = merge(merge(tl, tr), sr);
    return cnt;
  }
};

/// }}}--- ///

RBSTMultiset&lt; ll &gt;* ms = nullptr;
</code></pre>

<p><span class="lib-title">Treap Sequence Library</span></p>

<pre><code>/// --- Treap Sequence Library {{{ ///

template &lt; class Monoid, class M_act &gt;
struct TreapSeq {
private:
  using u32 = uint32_t;
  using X = typename Monoid::T;
  using M = typename M_act::M;
  TreapSeq *l = nullptr, *r = nullptr;
  X val;
  X accum = Monoid::identity();
  M lazy = M_act::identity();
  bool rev = false;
  int sz = 1;
  u32 pri;
  // call after touch its child
  // a is not nullptr and is evaled, its child is proped
  friend TreapSeq *prop(TreapSeq *a) {
    a-&gt;sz = size(a-&gt;l) + 1 + size(a-&gt;r);
    a-&gt;accum =
        Monoid::op(Monoid::op(Accumulated(a-&gt;l), a-&gt;val), Accumulated(a-&gt;r));
    return a;
  }
  // call before use val, accum
  friend void eval(TreapSeq *a) {
    if(a-&gt;lazy != M_act::identity()) {
      a-&gt;val = M_act::actInto(a-&gt;lazy, -1, 1, a-&gt;val);
      a-&gt;accum = M_act::actInto(a-&gt;lazy, -1, a-&gt;sz, a-&gt;accum);
      if(a-&gt;l != nullptr) a-&gt;l-&gt;lazy = M_act::op(a-&gt;lazy, a-&gt;l-&gt;lazy);
      if(a-&gt;r != nullptr) a-&gt;r-&gt;lazy = M_act::op(a-&gt;lazy, a-&gt;r-&gt;lazy);
      a-&gt;lazy = M_act::identity();
    }
    if(a-&gt;rev) {
      swap(a-&gt;l, a-&gt;r);
      if(a-&gt;l != nullptr) a-&gt;l-&gt;rev ^= 1;
      if(a-&gt;r != nullptr) a-&gt;r-&gt;rev ^= 1;
      a-&gt;rev = false;
    }
  }
  friend X Accumulated(TreapSeq *a) {
    return a == nullptr ? Monoid::identity() : (eval(a), a-&gt;accum);
  }
  /// --- XorShift128 {{{ ///
  struct XorShift128 {
    using u32 = uint32_t;
    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;
    XorShift128(u32 seed = 0) { z ^= seed; }
    u32 operator()() {
      u32 t = x ^ (x &lt;&lt; 11);
      x = y, y = z, z = w;
      return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
    }
  };
  /// }}}--- ///
  u32 nextPriority() {
    static XorShift128 xs(__LINE__ * 3 + 5);
    return xs();
  }

public:
  TreapSeq(X val, u32 pri) : val(val), pri(pri) {}
  TreapSeq(X val = Monoid::identity()) : TreapSeq(val, nextPriority()) {}
  friend TreapSeq *merge(TreapSeq *a, TreapSeq *b) {
    if(a == nullptr) return b;
    if(b == nullptr) return a;
    eval(a);
    eval(b);
    if(a-&gt;pri &gt; b-&gt;pri) {
      a-&gt;r = merge(a-&gt;r, b);
      return prop(a);
    } else {
      b-&gt;l = merge(a, b-&gt;l);
      return prop(b);
    }
  }
  friend int size(TreapSeq *a) { return a == nullptr ? 0 : a-&gt;sz; }
  using PNN = pair&lt; TreapSeq *, TreapSeq * &gt;;
  // [0, k), [k, n)
  // 左のグループにk個いれる
  friend PNN split(TreapSeq *a, int k) {
    if(a == nullptr) return PNN(nullptr, nullptr);
    eval(a);
    TreapSeq *sl, *sr;
    if(k &lt;= size(a-&gt;l)) {
      tie(sl, sr) = split(a-&gt;l, k);
      a-&gt;l = sr;
      return PNN(sl, prop(a));
    } else {
      tie(sl, sr) = split(a-&gt;r, k - size(a-&gt;l) - 1);
      a-&gt;r = sl;
      return PNN(prop(a), sr);
    }
  }
  friend void insert(TreapSeq *&amp;a, int k, const X &amp;x) {
    TreapSeq *sl, *sr;
    tie(sl, sr) = split(a, k);
    a = merge(sl, merge(new TreapSeq(x), sr));
  }
  friend X erase(TreapSeq *&amp;a, int k) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, k + 1);
    tie(tl, tr) = split(sl, k);
    a = merge(tl, sr);
    return tr-&gt;val;
  }
  friend void erase(TreapSeq *&amp;a, int l, int r) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    a = merge(tl, sr);
  }
  friend void set1(TreapSeq *a, int k, X const &amp;x) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, k + 1);
    tie(tl, tr) = split(sl, k);
    if(tr != nullptr) tr-&gt;val = tr-&gt;accum = x;
    merge(merge(tl, tr), sr);
  }
  friend X get(TreapSeq *a, int k) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, k + 1);
    tie(tl, tr) = split(sl, k);
    X res = tr == nullptr ? Monoid::identity() : tr-&gt;val;
    merge(merge(tl, tr), sr);
    return res;
  }
  friend void act(TreapSeq *a, int l, int r, M const &amp;m) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    if(tr != nullptr) tr-&gt;lazy = M_act::op(m, tr-&gt;lazy);
    merge(merge(tl, tr), sr);
  }
  friend X query(TreapSeq *a, int l, int r) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    X res = tr == nullptr ? Monoid::identity() : tr-&gt;accum;
    merge(merge(tl, tr), sr);
    return res;
  }
  friend void reverse(TreapSeq *a, int l, int r) {
    TreapSeq *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, r);
    tie(tl, tr) = split(sl, l);
    if(tr != nullptr) tr-&gt;rev ^= 1;
    merge(merge(tl, tr), sr);
  }
};

/// }}}--- ///

/// --- Monoid, M_act examples {{{ ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

// MinAdd m + x
// MinSet m
// SumAdd m * n + x
// SumSet m * n

struct RangeMinAdd {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll, const X &amp;x) { return m + x; }
};

struct RangeMinSet {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll, const X &amp;) { return m; }
};

struct RangeSumAdd {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;x) { return m * n + x; }
};

struct RangeSumSet {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;) { return m * n; }
};

/// }}}--- ///

TreapSeq&lt; RangeMin, RangeMinSet &gt; *seq = nullptr;
</code></pre>

<p><span class="lib-title">Treap Multiset Library</span></p>

<pre><code>/// --- Treap Multiset Library {{{ ///

template &lt; class Key &gt;
struct TreapMultiset {
public:
  const Key key;

private:
  using u32 = uint32_t;
  using PNN = pair&lt; TreapMultiset*, TreapMultiset* &gt;;
  u32 pri;
  TreapMultiset *l = nullptr, *r = nullptr;
  int sz = 1;
  // call after touch its child
  friend TreapMultiset* prop(TreapMultiset* a) {
    a-&gt;sz = size(a-&gt;l) + 1 + size(a-&gt;r);
    return a;
  }
  /// --- XorShift128 {{{ ///
  struct XorShift128 {
    using u32 = uint32_t;
    u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;
    XorShift128(u32 seed = 0) { z ^= seed; }
    u32 operator()() {
      u32 t = x ^ (x &lt;&lt; 11);
      x = y, y = z, z = w;
      return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
    }
  };
  /// }}}--- ///
  u32 nextPriority() {
    static XorShift128 xs(__LINE__ * 3 + 5);
    return xs();
  }

public:
  TreapMultiset(Key key, u32 pri) : key(key), pri(pri) {}
  TreapMultiset(Key key) : TreapMultiset(key, nextPriority()) {}
  friend TreapMultiset* merge(TreapMultiset* a, TreapMultiset* b) {
    if(a == nullptr) return b;
    if(b == nullptr) return a;
    if(a-&gt;pri &gt; b-&gt;pri) {
      a-&gt;r = merge(a-&gt;r, b);
      return prop(a);
    } else {
      b-&gt;l = merge(a, b-&gt;l);
      return prop(b);
    }
  }
  // lower (-inf, key), [key, inf)
  // upper (-inf, key], (key, inf)
  friend PNN split(TreapMultiset* a, Key key, bool upper) {
    if(a == nullptr) return PNN(nullptr, nullptr);
    TreapMultiset *sl, *sr;
    if(upper ? key &lt; a-&gt;key : !(a-&gt;key &lt; key)) {
      tie(sl, sr) = split(a-&gt;l, key, upper);
      a-&gt;l = sr;
      return PNN(sl, prop(a));
    } else {
      tie(sl, sr) = split(a-&gt;r, key, upper);
      a-&gt;r = sl;
      return PNN(prop(a), sr);
    }
  }
  friend PNN lower_split(TreapMultiset* a, const Key&amp; key) {
    return split(a, key, false);
  }
  friend PNN upper_split(TreapMultiset* a, const Key&amp; key) {
    return split(a, key, true);
  }
  friend int size(TreapMultiset* a) { return a == nullptr ? 0 : a-&gt;sz; }
  friend void insert(TreapMultiset*&amp; a, Key key) {
    TreapMultiset *sl, *sr;
    tie(sl, sr) = lower_split(a, key);
    a = merge(sl, merge(new TreapMultiset(key), sr));
  }
  friend void erase(TreapMultiset*&amp; a, Key key) {
    TreapMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = upper_split(a, key);
    tie(tl, tr) = lower_split(sl, key);
    a = merge(tl, sr);
  }
  friend void erase(TreapMultiset*&amp; a, Key keyL, Key keyR,
                    bool inclusive = false) {
    TreapMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, keyR, inclusive);
    tie(tl, tr) = lower_split(sl, keyL);
    a = merge(tl, sr);
  }
  friend void erase1(TreapMultiset*&amp; a, Key key) {
    if(a == nullptr) return;
    if(key &lt; a-&gt;key) {
      erase1(a-&gt;l, key);
    } else {
      if(!(a-&gt;key &lt; key)) {
        a = merge(a-&gt;l, a-&gt;r);
        return;
      }
      erase1(a-&gt;r, key);
    }
    prop(a);
  }
  friend Key getKth(TreapMultiset*&amp; a, int k) {
    static const struct CannotGetKthOfNullptr {} ex;
    if(a == nullptr) throw ex;
    if(k &lt;= size(a-&gt;l)) {
      if(k == size(a-&gt;l)) return a-&gt;key;
      return getKth(a-&gt;l, k);
    } else {
      return getKth(a-&gt;r, k - size(a-&gt;l) - 1);
    }
  }
  friend int count(TreapMultiset* a, Key key) {
    TreapMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = upper_split(a, key);
    tie(tl, tr) = lower_split(sl, key);
    int cnt = size(tr);
    merge(merge(tl, tr), sr);
    return cnt;
  }
  friend int count(TreapMultiset* a, Key keyL, Key keyR,
                   bool inclusive = false) {
    TreapMultiset *sl, *sr, *tl, *tr;
    tie(sl, sr) = split(a, keyR, inclusive);
    tie(tl, tr) = lower_split(sl, keyL);
    int cnt = size(tr);
    merge(merge(tl, tr), sr);
    return cnt;
  }
};

/// }}}--- ///

TreapMultiset&lt; ll &gt;* ms = nullptr;
</code></pre>

<p><span class="lib-title">LeftistHeap Library</span></p>

<pre><code>/// --- LeftistHeap Library {{{ ///
template &lt; class T &gt;
struct LeftistHeap {
  LeftistHeap *l = nullptr, *r = nullptr;
  T val;
  int rnk;
  LeftistHeap(T val = T()) : val(val) {}
};

template &lt; class T, class Compare = less&lt; T &gt; &gt;
LeftistHeap&lt; T &gt; *meld(LeftistHeap&lt; T &gt; *a, LeftistHeap&lt; T &gt; *b,
                       const Compare &amp;comp = Compare()) {
  if(a == nullptr) return b;
  if(b == nullptr) return a;
  if(!comp(a-&gt;val, b-&gt;val)) swap(a, b);
  a-&gt;r = meld(a-&gt;r, b, comp);
  if(a-&gt;l == nullptr || a-&gt;l-&gt;rnk &lt; a-&gt;r-&gt;rnk) swap(a-&gt;l, a-&gt;r);
  a-&gt;rnk = ((a-&gt;r == nullptr) ? 0 : a-&gt;r-&gt;rnk) + 1;
  return a;
}

template &lt; class T, class Compare = less&lt; T &gt; &gt;
inline LeftistHeap&lt; T &gt; *push(LeftistHeap&lt; T &gt; *&amp;a, T const &amp;e,
                              const Compare &amp;comp = Compare()) {
  LeftistHeap&lt; T &gt; *b = new LeftistHeap&lt; T &gt;(e);
  a = a == nullptr ? b : meld(a, b, comp);
  return b;
}

template &lt; class T, class Compare = less&lt; T &gt; &gt;
inline void pop(LeftistHeap&lt; T &gt; *&amp;a, const Compare &amp;comp = Compare()) {
  a = meld(a-&gt;l, a-&gt;r, comp);
}
template &lt; class T, class Compare = less&lt; T &gt; &gt;
LeftistHeap&lt; T &gt; *second(LeftistHeap&lt; T &gt; *a, const Compare &amp;comp = Compare()) {
  return a-&gt;r == nullptr ? a-&gt;l : comp(a-&gt;l-&gt;val, a-&gt;r-&gt;val) ? a-&gt;l : a-&gt;r;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">SkewHeap Library</span></p>

<pre><code>/// --- SkewHeap Library {{{ ///
template &lt; class T &gt;
struct SkewHeap {
  SkewHeap *l = nullptr, *r = nullptr;
  T val;
  SkewHeap(T val = T()) : val(val) {}
};

template &lt; class T, class Compare = less&lt; T &gt; &gt;
SkewHeap&lt; T &gt; *meld(SkewHeap&lt; T &gt; *a, SkewHeap&lt; T &gt; *b,
                    const Compare &amp;comp = Compare()) {
  if(a == nullptr) return b;
  if(b == nullptr) return a;
  if(!comp(a-&gt;val, b-&gt;val)) swap(a, b);
  a-&gt;r = meld(a-&gt;r, b, comp);
  swap(a-&gt;l, a-&gt;r);
  return a;
}

template &lt; class T, class Compare = less&lt; T &gt; &gt;
inline SkewHeap&lt; T &gt; *push(SkewHeap&lt; T &gt; *&amp;a, T const &amp;e,
                           const Compare &amp;comp = Compare()) {
  SkewHeap&lt; T &gt; *b = new SkewHeap&lt; T &gt;(e);
  a = a == nullptr ? b : meld(a, b, comp);
  return b;
}

template &lt; class T, class Compare = less&lt; T &gt; &gt;
inline void pop(SkewHeap&lt; T &gt; *&amp;a, const Compare &amp;comp = Compare()) {
  a = meld(a-&gt;l, a-&gt;r, comp);
}
template &lt; class T, class Compare = less&lt; T &gt; &gt;
SkewHeap&lt; T &gt; *second(SkewHeap&lt; T &gt; *a, Compare comp = Compare()) {
  return a-&gt;r == nullptr ? a-&gt;l : comp(a-&gt;l-&gt;val, a-&gt;r-&gt;val) ? a-&gt;l : a-&gt;r;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">BIT Library</span></p>

<pre><code>// NOTE : there's get and sum method.
/// --- BIT Library {{{ ///

template &lt; class T = ll &gt;
struct BIT {
  int n, m;
  T identity;
  vector&lt; T &gt; data;
  BIT() : n(0) {}
  BIT(int n, T identity = T()) : n(n), identity(identity), data(n, identity) {
    m = 1;
    while(m &lt; n) m &lt;&lt;= 1;
  }
  void add(int i, T x) {
    i++;
    while(i &lt;= n) {
      data[i - 1] = data[i - 1] + x;
      i += i &amp; -i;
    }
  }
  T sum(int i) {
    if(i &lt; 0) return identity;
    if(i &gt;= n) i = n - 1;
    i++;
    T s = identity;
    while(i &gt; 0) {
      s = s + data[i - 1];
      i -= i &amp; -i;
    }
    return s;
  }
  T get(int i) { return sum(i) - inverse(sum(i - 1)); }
  T range(int a, int b) { return sum(b) - inverse(sum(a - 1)); }
  int lower_bound(T w) {
    int i = 0;
    for(int k = m; k &gt; 0; k &gt;&gt;= 1) {
      if(i + k &lt;= n &amp;&amp; data[i + k - 1] &lt; w) w -= data[(i += k) - 1];
    }
    return i;
  }
};

/// }}}--- ///

// BIT&lt;&gt; bit(N);
</code></pre>

<p><span class="lib-title">2D BIT Library</span></p>

<pre><code>// NOTE : query in range and x1 &lt;= x2, y is same
/// --- 2D BIT Library {{{ ///

template &lt; class T = ll, class V = function&lt; T(T, T) &gt; &gt;
struct BIT2D {
  int h, w;
  T identity;
  vector&lt; T &gt; dat;
  BIT2D(int h, int w, T identity = T())
      : h(h), w(w), identity(identity), dat(h * w, identity) {}
  void add(int y, int x, T const &amp;val) {
    for(++y; y &lt;= h; y += y &amp; -y) addX(y, x, val);
  }
  void addRange(int y1, int x1, int y2, int x2, T const &amp;val) {
    add(y1, x1, val);
    if(y2 + 1 &lt; h) add(y2 + 1, x1, -val);
    if(x2 + 1 &lt; w) add(y1, x2 + 1, -val);
    if(y2 + 1 &lt; h &amp;&amp; x2 + 1 &lt; w) add(y2 + 1, x2 + 1, val);
  }
  void set(int y, int x, T val) { add(y, x, val - get(y, x)); }
  T sum(int y, int x) {
    if(y &lt; 0 || x &lt; 0) return 0;
    T r = identity;
    for(++y; y &gt; 0; y -= y &amp; -y) r += sumX(y, x);
    return r;
  }
  T get(int y, int x) { return range(y, x, y, x); }
  T range(int y1, int x1, int y2, int x2) {
    return sum(y2, x2) - sum(y1 - 1, x2) - sum(y2, x1 - 1) +
           sum(y1 - 1, x1 - 1);
  }

private:
  inline int id(int y, int x) { return (y - 1) * w + (x - 1); }
  void addX(int y, int x, T const &amp;val) {
    for(++x; x &lt;= w; x += x &amp; -x) dat[id(y, x)] += val;
  }
  T sumX(int y, int x) {
    T r = identity;
    for(++x; x &gt; 0; x -= x &amp; -x) r += dat[id(y, x)];
    return r;
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">LinkCutTree Library</span></p>

<pre><code>// when link(p, c) , c is root.
// cut(c), c is not root
// use make(int index, Monoid::T x)
// lc[index] to access nodes
/// --- LinkCutTree Library {{{ ///

template &lt; class Monoid, class M_act &gt;
struct LinkCutTree {
  using X = typename Monoid::T;
  using M = typename M_act::M;

  // Splay sequence {{{
  struct Splay {
    Splay *ch[2] = {nullptr, nullptr}, *p = nullptr;
    X val, accum;
    M lazy = M_act::identity(); ///////
    // size of BST // not of real subtree
    int sz = 1;
    bool isRoot() { return !p || (p-&gt;ch[0] != this &amp;&amp; p-&gt;ch[1] != this); }
    bool rev = false;
    // call before use
    void eval() {
      if(lazy != M_act::identity()) {
        val = M_act::actInto(lazy, -1, 1, val);
        accum = M_act::actInto(lazy, -1, sz, accum);
        if(ch[0]) ch[0]-&gt;lazy = M_act::op(lazy, ch[0]-&gt;lazy);
        if(ch[1]) ch[1]-&gt;lazy = M_act::op(lazy, ch[1]-&gt;lazy);
        lazy = M_act::identity();
      }
      if(rev) {
        swap(ch[0], ch[1]);
        if(ch[0]) ch[0]-&gt;rev ^= 1;
        if(ch[1]) ch[1]-&gt;rev ^= 1;
        // accum = reverse(accum, sz)
        rev = false;
      }
    }
    void evalDown() {
      vector&lt; Splay * &gt; b2t;
      Splay *t = this;
      for(; !t-&gt;isRoot(); t = t-&gt;p) b2t.emplace_back(t);
      t-&gt;eval();
      while(b2t.size()) b2t.back()-&gt;eval(), b2t.pop_back();
      // vector&lt; Splay * &gt;().swap(b2t);
    }
    X accumulated(Splay *a) { return !a ? Monoid::identity() : a-&gt;accum; }
    int size(Splay *a) { return !a ? 0 : a-&gt;sz; }
    // call after touch
    void prop() {
      if(ch[0]) ch[0]-&gt;eval(); ////
      if(ch[1]) ch[1]-&gt;eval(); ////
      sz = size(ch[0]) + 1 + size(ch[1]);
      accum =
          Monoid::op(Monoid::op(accumulated(ch[0]), val), accumulated(ch[1]));
    }
    Splay(const X &amp;val) : val(val), accum(val) {}
    Splay *rotate(bool R) {
      Splay *t = ch[!R];
      if((ch[!R] = t-&gt;ch[R])) ch[!R]-&gt;p = this;
      t-&gt;ch[R] = this; ////
      if((t-&gt;p = p)) {
        if(t-&gt;p-&gt;ch[0] == this) t-&gt;p-&gt;ch[0] = t;
        if(t-&gt;p-&gt;ch[1] == this) t-&gt;p-&gt;ch[1] = t;
      }
      p = t;
      prop(), t-&gt;prop();
      return t;
    }
    // bottom-up
    void splay() {
      evalDown();
      while(!isRoot()) {
        Splay *q = p;
        if(q-&gt;isRoot()) {
          q-&gt;rotate(q-&gt;ch[0] == this);
        } else {
          Splay *r = q-&gt;p;
          bool V = r-&gt;ch[0] == q;
          if(q-&gt;ch[!V] == this)
            r-&gt;rotate(V);
          else
            q-&gt;rotate(!V);
          p-&gt;rotate(V); ///////
        }
      }
    }
  };
  // }}}

  vector&lt; Splay * &gt; data;
  LinkCutTree(int n) : data(n) {}
  Splay *operator[](int i) { return data[i]; }
  Splay *make(int i, const X &amp;x = Monoid::identity()) {
    return data[i] = new Splay(x);
  }
  const X &amp;get(Splay *x) {
    x-&gt;evalDown();
    return x-&gt;val;
  }
  void set(Splay *x, const X &amp;val) {
    x-&gt;splay();
    x-&gt;val = val;
    x-&gt;prop();
  }
  Splay *expose(Splay *x) {
    Splay *prv = nullptr, *now = x;
    for(; now; prv = now, now = now-&gt;p) {
      now-&gt;splay();
      now-&gt;ch[1] = prv;
      now-&gt;prop();
    }
    x-&gt;splay(); /////
    return prv;
  }
  void cut(Splay *c) {
    expose(c);
#ifdef DEBUG
    static const struct CannotCutRoot {} ex;
    if(!c-&gt;ch[0]) throw ex;
#endif
    Splay *s = c-&gt;ch[0];
    c-&gt;ch[0] = nullptr;
    c-&gt;prop();
    s-&gt;p = nullptr;
  }
  void link(Splay *parent, Splay *child) {
#ifdef DEBUG
    static const struct CannotLinkSameNode {} ex;
    if(same(parent, child)) throw ex;
#endif
    expose(parent), expose(child);
    child-&gt;p = parent;
    parent-&gt;ch[1] = child;
    parent-&gt;prop();
  }
  void evert(Splay *x) {
    expose(x);
    x-&gt;rev = true;
  }
  bool same(Splay *a, Splay *b) {
    if(a == b) return true;
    expose(a), expose(b);
    return a-&gt;p != nullptr;
  }
  Splay *lca(Splay *a, Splay *b) {
#ifdef DEBUG
    static const struct CannotLCAAnotherNode {} ex;
    if(!same(a, b)) throw ex;
#endif
    expose(a), a = expose(b);
    return !a ? b : a;
  }
  void act(Splay *a, const M &amp;m) { expose(a), a-&gt;lazy = m; }
  X query(Splay *a) {
    expose(a);
    return a-&gt;accum;
  }
  // root of subtree
  Splay *getRoot(Splay *a) {
    expose(a);
    Splay *t = a;
    while(t-&gt;ch[0]) t = t-&gt;ch[0];
    t-&gt;splay();
    return t;
  }
};

/// }}}--- ///

/// --- Monoid, M_act examples {{{ ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

// MinAdd m + x
// MinSet m
// SumAdd m * n + x
// SumSet m * n

struct RangeMinAdd {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll, const X &amp;x) { return m + x; }
};

struct RangeMinSet {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll, const X &amp;) { return m; }
};

struct RangeSumAdd {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;x) { return m * n + x; }
};

struct RangeSumSet {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;) { return m * n; }
};

/// }}}--- ///

// LinkCutTree&lt; RangeSum, RangeSumSet &gt; lc(N);
</code></pre>

<p><span class="lib-title">Sparse Table Library</span></p>

<pre><code>// NOTE : query in range!
/// --- Sparse Table Library {{{ ///

template &lt; class SemiLattice &gt;
struct SparseTable {
  using T = typename SemiLattice::T;
  size_t n;
  vector&lt; size_t &gt; log2;
  vector&lt; vector&lt; T &gt; &gt; t;
  T identity;
  SparseTable() : n(0) {}
  SparseTable(size_t n, T identity = T())
      : n(n), log2(n + 1), identity(identity) {
    for(size_t i = 2; i &lt;= n; i++) log2[i] = log2[i &gt;&gt; 1] + 1;
    t.resize(log2[n] + 1, vector&lt; T &gt;(n, identity));
  }
  template &lt; class InputIter,
             class = typename iterator_traits&lt; InputIter &gt;::value_type &gt;
  SparseTable(InputIter first, InputIter last, T identity = T())
      : SparseTable(distance(first, last), identity) {
    copy(first, last, begin(t[0]));
    build();
  }
  void set(size_t i, T val) { t[0][i] = val; }
  T get(size_t i) { return t[0][i]; }
  void build() {
    for(size_t j = 0; j &lt; log2[n]; j++) {
      size_t w = 1 &lt;&lt; j;
      for(size_t i = 0; i + (w &lt;&lt; 1) &lt;= n; i++) {
        t[j + 1][i] = SemiLattice::op(t[j][i], t[j][i + w]);
      }
    }
  }
  T query(size_t l, size_t r) {
    if(r - l &lt; 1) return identity;
    size_t j = log2[r - l];
    return SemiLattice::op(t[j][l], t[j][r - (1 &lt;&lt; j)]);
  }
};

/// }}}--- ///

// SemiLattice examples {{{

struct RMQSL {
  using T = int;
  static T op(T const &amp;a, T const &amp;b) { return a &lt; b ? a : b; }
};

// }}}

SparseTable&lt; RMQSL &gt; rmq(N, inf);
</code></pre>

<p><span class="lib-title">Union Find Library</span></p>

<pre><code>/// --- Union Find Library {{{ ///

struct UF {
  int n;
  vector&lt; int &gt; par, rank;
  UF(int n) : n(n), par(n, -1), rank(n, 0) {}
  int find(int x) { return par[x] &lt; 0 ? x : par[x] = find(par[x]); }
  int size(int x) { return -par[find(x)]; }
  bool same(int a, int b) { return find(a) == find(b); }
  void unite(int a, int b) {
    a = find(a);
    b = find(b);
    if(a == b) return;
    if(rank[a] &gt; rank[b]) swap(a, b);
    par[b] += par[a];
    par[a] = b;
    if(rank[a] == rank[b]) rank[b]++;
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">DynamicSegTree</span></p>

<pre><code>// Note : to get faster, use map by yourself
// .entity : number of materialized leaves
/// --- DynamicSegTree {{{ ///

template &lt; class Monoid &gt;
struct DynamicSegTree {
  using T = typename Monoid::T;
  struct Node {
    T value;
    Node *l = nullptr, *r = nullptr;
    Node(T value = Monoid::identity()) : value(value) {}
  };
  Node *top = new Node;
  int n;
  DynamicSegTree() {}
  DynamicSegTree(int t) {
    n = 1;
    while(t &gt; n) n &lt;&lt;= 1;
  }
  void set(int i, T const &amp;val) { set(i, val, 0, n, top); }

private:
  void set(int i, T const &amp;val, int l, int r, Node *&amp;node) {
    if(i + 1 &lt;= l || r &lt;= i) return;
    if(node == nullptr) node = new Node();
    if(i &lt;= l &amp;&amp; r &lt;= i + 1) {
      node-&gt;value = val;
      return;
    }
    set(i, val, l, (l + r) / 2, node-&gt;l);
    set(i, val, (l + r) / 2, r, node-&gt;r);
    node-&gt;value = Monoid::op(calc(node-&gt;l), calc(node-&gt;r));
  }
  inline T calc(Node *node) {
    return node == nullptr ? Monoid::identity() : node-&gt;value;
  }

public:
  T query(int a, int b) {
    if(a &lt; 0 || b &gt; n || b &lt;= a) return Monoid::identity();
    return query(a, b, 0, n, top);
  }
  T get(int i) { return query(i, i + 1); }

private:
  T query(int a, int b, int l, int r, Node *node) {
    if(node == nullptr) return Monoid::identity();
    if(b &lt;= l || r &lt;= a) return Monoid::identity();
    if(a &lt;= l &amp;&amp; r &lt;= b) return node-&gt;value;
    return Monoid::op(query(a, b, l, (l + r) / 2, node-&gt;l),
                      query(a, b, (l + r) / 2, r, node-&gt;r));
  }
};

/// }}}--- ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

using RMQ = DynamicSegTree&lt; RMQMonoid &gt;;
using RSQ = DynamicSegTree&lt; RSQMonoid &gt;;
using RMaxQ = DynamicSegTree&lt; RMaxQMonoid &gt;;
</code></pre>

<p><span class="lib-title">Fractional Cascading SegmentTree Library</span></p>

<pre><code>// (y, x)
// query(yl, yr, xl, xr)
// only offline
// only one update
/// --- Fractional Cascading SegmentTree Library {{{ ///

template &lt; class T, class U, class Index = ll &gt;
struct FractionalCascadingSegTree {
  int h;
  vector&lt; T &gt; dat;
  vector&lt; vector&lt; Index &gt; &gt; indices;
  vector&lt; vector&lt; int &gt; &gt; L, R;
  U identity;
  function&lt; void(T &amp;, int x, const U &amp;) &gt; setX;
  function&lt; void(T &amp;, vector&lt; Index &gt; &amp;) &gt; initX;
  function&lt; U(T &amp;, int x1, int x2) &gt; queryX;
  function&lt; U(const U &amp;, const U &amp;) &gt; mergeX;
  FractionalCascadingSegTree() {}
  FractionalCascadingSegTree(
      int tempH, //
      function&lt; void(T &amp;, int, const U &amp;) &gt; const &amp;setX,
      function&lt; void(T &amp;, vector&lt; Index &gt; &amp;) &gt; const &amp;initX,
      function&lt; U(T &amp;, int, int) &gt; const &amp;queryX,
      function&lt; U(const U &amp;, const U &amp;) &gt; const &amp;mergeX, U identity = U(),
      T initial = T())
      : identity(identity),
        setX(setX),
        initX(initX),
        queryX(queryX),
        mergeX(mergeX) {
    h = 1;
    while(h &lt; tempH) h &lt;&lt;= 1;
    dat = vector&lt; T &gt;(2 * h, initial);
    indices = vector&lt; vector&lt; Index &gt; &gt;(2 * h);
    L = R = vector&lt; vector&lt; int &gt; &gt;(2 * h);
  }
  void index(int i, Index j) { indices[i + h - 1].emplace_back(j); }
  void init(bool doUnique) {
    for(int i = h * 2 - 2; i &gt;= 0; i--) {
      if(i &gt;= h - 1) {
        sort(begin(indices[i]), end(indices[i]));
        if(doUnique)
          indices[i].erase(
              unique(begin(indices[i]), end(indices[i])), end(indices[i]));
        initX(dat[i], indices[i]);
        continue;
      }
      size_t lsz = indices[i * 2 + 1].size();
      size_t rsz = indices[i * 2 + 2].size();
      size_t nsz = lsz + rsz;
      indices[i].resize(nsz);
      L[i].resize(nsz + 1, lsz);
      R[i].resize(nsz + 1, rsz);
      size_t p1 = 0, p2 = 0;
      while(p1 &lt; lsz || p2 &lt; rsz) {
        L[i][p1 + p2] = p1;
        R[i][p1 + p2] = p2;
        if(p1 &lt; lsz &amp;&amp;
           (p2 == rsz || indices[i * 2 + 1][p1] &lt;= indices[i * 2 + 2][p2])) {
          indices[i][p1 + p2] = indices[i * 2 + 1][p1];
          p1++;
        } else {
          indices[i][p1 + p2] = indices[i * 2 + 2][p2];
          p2++;
        }
      }
      initX(dat[i], indices[i]);
    }
  }
  void set(int i, int j, U const &amp;val) {
    int lower =
        lower_bound(begin(indices[0]), end(indices[0]), j) - begin(indices[0]);
    set(i, lower, val, 0, h, 0);
  }
  void set(int i, int lower, U const &amp;val, int l, int r, int k) {
    if(i + 1 &lt;= l || r &lt;= i) return;
    upd(dat[k], i, lower, val);
    if(i &lt;= l &amp;&amp; r &lt;= i + 1) return;
    set(i, L[k][lower], val, l, (l + r) &gt;&gt; 1, k * 2 + 1);
    set(i, R[k][lower], val, (l + r) &gt;&gt; 1, r, k * 2 + 2);
  }
  U query(int a, int b, int l, int r) {
    int lower =
        lower_bound(begin(indices[0]), end(indices[0]), l) - begin(indices[0]);
    int upper =
        lower_bound(begin(indices[0]), end(indices[0]), r) - begin(indices[0]);
    return query(a, b, lower, upper, 0, h, 0);
  }
  U query(int a, int b, int lower, int upper, int l, int r, int k) {
    if(b &lt;= l || r &lt;= a) return identity;
    if(a &lt;= l &amp;&amp; r &lt;= b) return queryX(dat[k], lower, upper);
    return mergeX(
        query(a, b, L[k][lower], L[k][upper], l, (l + r) &gt;&gt; 1, k * 2 + 1),
        query(a, b, R[k][lower], R[k][upper], (l + r) &gt;&gt; 1, r, k * 2 + 2));
  }
};

/// }}}--- ///

// fc-seg expamle {{{

// using Under = BIT&lt;&gt;;
// using Data = ll;

using Under = SparseTable&lt; RMQSL &gt;;
using Value = RMQSL;
using Data = Value::T;

FractionalCascadingSegTree&lt; Under, Data &gt; ecas(
    N + 1,
    // set y
    [](Under &amp;dat, int y, Data const &amp;v) -&gt; void {
      dat.set(y, Value::op(dat.get(y), v));
    },
    // init y
    [](Under &amp;dat, vector&lt; ll &gt; indices) -&gt; void {
      dat = Under(indices.size()); // serve initial?
    },
    // [l, r) // WARN : l &lt;= r
    [](Under &amp;dat, int l, int r) -&gt; Data { return dat.query(l, r); },
    // merge y-direction
    [](Data a, Data b) -&gt; Data { return a + b; });

// }}}
</code></pre>

<p><span class="lib-title">LazySegmentTree Library</span></p>

<pre><code>// NOTE : query in range!
/// --- LazySegmentTree Library {{{ ///

template &lt; class Monoid, class M_act &gt;
struct LazySegTree {
private:
  using X = typename Monoid::T;
  using M = typename M_act::M;
  int n, h;
  std::vector&lt; X &gt; data;
  std::vector&lt; M &gt; lazy;
  std::vector&lt; int &gt; nodeLeft;
  std::vector&lt; int &gt; nodeLength;
  // call before use data[i]
  void eval(int i) {
    if(lazy[i] == M_act::identity()) return;
    data[i] = M_act::actInto(lazy[i], nodeLeft[i], nodeLength[i], data[i]);
    if(i &lt; n) {
      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);
      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);
    }
    lazy[i] = M_act::identity();
  }
  // call before use seg[i] = data[i + n]
  void evalDown(int i) {
    i += n;
    for(int j = h - 1; j &gt;= 0; j--) eval(i &gt;&gt; j);
  }
  // call after touch seg[i] = data[i + n]
  void propUp(int i) {
    i += n;
    while(i &gt;&gt;= 1)
      eval(i * 2), eval(i * 2 + 1),
          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);
  }

public:
  LazySegTree() : n(0) {}
  LazySegTree(int n, X initial = Monoid::identity()) : n(n) {
    h = 1;
    while(1 &lt;&lt; h &lt; n) h++;
    data.resize(2 * n, initial);
    lazy.resize(2 * n, M_act::identity());
    nodeLeft.resize(2 * n);
    nodeLength.resize(2 * n, 1);
    for(int i = 0; i &lt; n; i++) nodeLeft[i + n] = i;
    for(int i = n - 1; i &gt; 0; i--) // fill from deep
      data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),
      nodeLeft[i] = min(nodeLeft[i * 2], nodeLeft[i * 2 + 1]),
      nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];
  }
  template &lt; class InputIter,
             class = typename std::iterator_traits&lt; InputIter &gt;::value_type &gt;
  LazySegTree(InputIter first, InputIter last)
      : LazySegTree(std::distance(first, last)) {
    copy(first, last, std::begin(data) + n);
    for(int i = n - 1; i &gt; 0; i--) // fill from deep
      data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);
  }
  void act(int l, int r, const M &amp;m) {
    evalDown(l);
    evalDown(r - 1);
    int tl = l, tr = r;
    for(l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) eval(l), lazy[l] = m, eval(l), l++;
      if(r &amp; 1) --r, eval(r), lazy[r] = m, eval(r);
    }
    propUp(tl);
    propUp(tr - 1);
  }
  void set(int i, const X &amp;x) {
    evalDown(i);
    data[i + n] = x;
    propUp(i);
  }
  X get(int i) {
    evalDown(i);
    return data[i + n];
  }
  X query(int l, int r) {
    evalDown(l);
    evalDown(r - 1);
    X tmpL = Monoid::identity(), tmpR = Monoid::identity();
    for(l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;
      if(r &amp; 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);
    }
    return Monoid::op(tmpL, tmpR);
  }
  inline void dum(int r = -1) {
#ifdef DEBUG
    if(r &lt; 0) r = n;
    DEBUG_OUT &lt;&lt; "{";
    for(int i = 0; i &lt; std::min(r, n); i++)
      DEBUG_OUT &lt;&lt; (i ? ", " : "") &lt;&lt; get(i);
    DEBUG_OUT &lt;&lt; "}" &lt;&lt; std::endl;
#endif
  }
};

/// }}}--- ///

/// --- Monoid, M_act examples {{{ ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

// MinAdd m + x
// MinSet m
// SumAdd m * n + x
// SumSet m * n

struct RangeMinAdd {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll, const X &amp;x) { return m + x; }
};

struct RangeMinSet {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll, const X &amp;) { return m; }
};

struct RangeSumAdd {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;x) { return m * n + x; }
};

struct RangeSumSet {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;) { return m * n; }
};

/// }}}--- ///

LazySegTree&lt; RangeSum, RangeSumAdd &gt; seg(N);
</code></pre>

<p><span class="lib-title">PersistentSegmentTree Library</span></p>

<pre><code>// NOTE : query in range!
/// --- PersistentSegmentTree Library {{{ ///

template &lt; class Monoid &gt;
struct PersistentSegTree {
private:
  using T = typename Monoid::T;
  int n;
  vector&lt; T &gt; data;
  vector&lt; int &gt; lch, rch;
  int lastRoot = 0;

public:
  PersistentSegTree() : n(0) {}
  PersistentSegTree(int t) : data(1, Monoid::identity()), lch(1, 0), rch(1, 0) {
    n = 1;
    while(n &lt; t) n &lt;&lt;= 1;
  }
  template &lt; class InputIter,
             class = typename iterator_traits&lt; InputIter &gt;::value_type &gt;
  PersistentSegTree(InputIter first, InputIter last)
      : PersistentSegTree(distance(first, last)) {
    assign(first, last);
  }
  int set(int i, const T &amp;v, int root = 0) {
    if(root == 0) root = lastRoot;
    int k = make();
    set(i, v, 0, n, k, root);
    lastRoot = k;
    return k;
  }
  template &lt; class InputIter,
             class = typename iterator_traits&lt; InputIter &gt;::value_type &gt;
  void assign(InputIter first, InputIter last) {
    assert(n &gt;= distance(first, last));
    data.resize(n * 2 - 1, Monoid::identity());
    lch.resize(n * 2 - 1, 0);
    rch.resize(n * 2 - 1, 0);
    copy(first, last, begin(data) + n - 1);
    for(int i = n - 2; i &gt;= 0; i--) {
      data[i] = Monoid::op(data[lch[i] = i * 2 + 1], data[rch[i] = i * 2 + 2]);
    }
  }
  void reserve(int qsize) {
    int h = log(n);
    data.reserve(n * 2 - 1 + qsize * h);
    lch.reserve(n * 2 - 1 + qsize * h);
    rch.reserve(n * 2 - 1 + qsize * h);
  }
  void set(int i, const T &amp;v, int l, int r, int k, int prevK) {
    if(r - l == 1) {
      data[k] = v;
      return;
    }
    lch[k] = lch[prevK];
    rch[k] = rch[prevK];
    int x = make(); //// important where to calc
    if(i &lt; ((l + r) &gt;&gt; 1)) {
      lch[k] = x;
      set(i, v, l, (l + r) &gt;&gt; 1, lch[k], lch[prevK]);
    } else {
      rch[k] = x;
      set(i, v, (l + r) &gt;&gt; 1, r, rch[k], rch[prevK]);
    }
    data[k] = Monoid::op(data[lch[k]], data[rch[k]]);
  }
  T get(int i, int root = 0) { return query(i, i + 1, root); }
  T query(int a, int b, int root = 0) {
    if(root == 0) root = lastRoot;
    return query(a, b, 0, n, root);
  }
  T query(int a, int b, int l, int r, int k) {
    if(k == 0) return Monoid::identity();
    if(b &lt;= l || r &lt;= a) return Monoid::identity();
    if(a &lt;= l &amp;&amp; r &lt;= b) return data[k];
    return Monoid::op(query(a, b, l, (l + r) &gt;&gt; 1, lch[k]),
                      query(a, b, (l + r) &gt;&gt; 1, r, rch[k]));
  }

private:
  int make() {
    data.emplace_back(Monoid::identity());
    lch.emplace_back(0);
    rch.emplace_back(0);
    return data.size() - 1;
  }
  int log(int x) {
    int t = 0;
    while(x) x &gt;&gt;= 1, t++;
    return t;
  }
};

/// }}}--- ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

using RMQ = PersistentSegTree&lt; RMQMonoid &gt;;
using RSQ = PersistentSegTree&lt; RSQMonoid &gt;;
using RMaxQ = PersistentSegTree&lt; RMaxQMonoid &gt;;
</code></pre>

<p><span class="lib-title">SegmentTree Library</span></p>

<pre><code>// NOTE : query in range!
/// --- SegmentTree Library {{{ ///

template &lt; class Monoid &gt;
struct SegTree {
private:
  using T = typename Monoid::T;
  int n;
  vector&lt; T &gt; data;
  // call after touch data[i]
  void prop(int i) { data[i] = Monoid::op(data[2 * i], data[2 * i + 1]); }

public:
  SegTree() : n(0) {}
  SegTree(int n, T initial = Monoid::identity()) : n(n) {
    data.resize(n * 2, initial);
    for(int i = n - 1; i &gt; 0; i--)
      data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);
  }
  template &lt; class InputIter,
             class = typename iterator_traits&lt; InputIter &gt;::value_type &gt;
  SegTree(InputIter first, InputIter last) : SegTree(distance(first, last)) {
    copy(first, last, begin(data) + n);
    // fill from deep
    for(int i = n - 1; i &gt; 0; i--) prop(i);
  }
  void set(int i, const T &amp;v) {
    data[i += n] = v;
    while(i &gt;&gt;= 1) prop(i); // propUp
  }
  T get(int i) { return data[i + n]; }
  T query(int l, int r) {
    T tmpL = Monoid::identity(), tmpR = Monoid::identity();
    for(l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) tmpL = Monoid::op(tmpL, data[l++]);
      if(r &amp; 1) tmpR = Monoid::op(data[--r], tmpR);
    }
    return Monoid::op(tmpL, tmpR);
  }
  inline void dum(int r = -1) {
#ifdef DEBUG
    if(r &lt; 0) r = n;
    DEBUG_OUT &lt;&lt; "{";
    for(int i = 0; i &lt; min(r, n); i++) DEBUG_OUT &lt;&lt; (i ? ", " : "") &lt;&lt; get(i);
    DEBUG_OUT &lt;&lt; "}" &lt;&lt; endl;
#endif
  }
};

/// }}}--- ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

using RMQ = SegTree&lt; RangeMin &gt;;
RMQ rmq(N);
</code></pre>

<p><span class="lib-title">2D SegmentTree Library</span></p>

<pre><code>// constructor(int sizex, int sizey, T identity, func merge)
// WARN : query in range by yourself!
/// --- 2D SegmentTree Library {{{ ///

template &lt; class T &gt;
struct SegTree2D {
  vector&lt; T &gt; dat;
  int sizex, sizey;
  T identity;
  function&lt; T(T, T) &gt; merge;
  SegTree2D(int tx, int ty, T identity, function&lt; T(T, T) &gt; merge)
      : identity(identity), merge(merge) {
    sizex = sizey = 1;
    while(tx &gt; sizex) sizex &lt;&lt;= 1;
    while(ty &gt; sizey) sizey &lt;&lt;= 1;
    dat = vector&lt; T &gt;(sizex * sizey * 4, identity);
  }
  void set(int x, int y, T const &amp;val) {
    int kx = x + sizex - 1, ky = y + sizey - 1;
    dat[kx * sizey * 2 + ky] = val;
    sety(kx, y);
    while(kx &gt; 0) {
      kx = (kx - 1) / 2;
      ky = y + sizey - 1;
      dat[kx * sizey * 2 + ky] = merge(dat[(kx * 2 + 1) * sizey * 2 + ky],
                                       dat[(kx * 2 + 2) * sizey * 2 + ky]);
      sety(kx, y);
    }
  }
  void act(int x, int y, T const &amp;val) {
    int kx = x + sizex - 1, ky = y + sizey - 1;
    set(x, y, merge(dat[kx * sizey * 2 + ky], val));
  }

private:
  void sety(int kx, int y) {
    int ky = y + sizey - 1;
    while(ky &gt; 0) {
      ky = (ky - 1) / 2;
      dat[kx * sizey * 2 + ky] = merge(
          dat[kx * sizey * 2 + ky * 2 + 1], dat[kx * sizey * 2 + ky * 2 + 2]);
    }
  }

public:
  T query(int xl, int xr, int yl, int yr) {
    return queryx(xl, xr, yl, yr, 0, sizex, 0);
  }

private:
  T queryx(int xl, int xr, int yl, int yr, int sxl, int sxr, int k) {
    if(xr &lt;= sxl || sxr &lt;= xl) return identity;
    if(xl &lt;= sxl &amp;&amp; sxr &lt;= xr) return queryy(k, yl, yr, 0, sizey, 0);
    return merge(queryx(xl, xr, yl, yr, sxl, (sxl + sxr) / 2, k * 2 + 1),
                 queryx(xl, xr, yl, yr, (sxl + sxr) / 2, sxr, k * 2 + 2));
  }
  T queryy(int kx, int yl, int yr, int syl, int syr, int k) {
    if(yr &lt;= syl || syr &lt;= yl) return identity;
    if(yl &lt;= syl &amp;&amp; syr &lt;= yr) return dat[kx * sizey * 2 + k];
    return merge(queryy(kx, yl, yr, syl, (syl + syr) / 2, k * 2 + 1),
                 queryy(kx, yl, yr, (syl + syr) / 2, syr, k * 2 + 2));
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Geometory Library</span></p>

<pre><code>using Scalar = long double;
// EPS
constexpr Scalar EPS = 1e-11;
constexpr Scalar PI = 3.14159265358979323;
/// --- Geometory Library {{{ ///
using Point = complex&lt; Scalar &gt;;
using Polygon = vector&lt; Point &gt;;
struct Line : public pair&lt; Point, Point &gt; {
  Line(Point a, Point b) : pair&lt; Point, Point &gt;(a, b) {}
};
struct Segment : public pair&lt; Point, Point &gt; {
  Segment(Point a, Point b) : pair&lt; Point, Point &gt;(a, b) {}
};
#define X real()
#define Y imag()
#define dot(a, b) real(conj(a) * (b))
#define cross(a, b) imag(conj(a) * (b))
#define norm abs

int sign(Scalar x) {
  if(x &lt; -EPS) return -1;
  if(x &gt; +EPS) return +1;
  return 0;
}

// +1 : a-&gt;b-&gt;c is ccw
// -1 : a-&gt;b-&gt;c is cw
// +2 : a--b--c
// -2 : b--c--a
//  0 : b--a--c
int ccw(const Point &amp;a, Point b, Point c) {
  b -= a;
  c -= a;
  if(cross(b, c) &gt; EPS) return +1;
  if(cross(b, c) &lt; -EPS) return -1;
  if(dot(b, c) &lt; 0) return 0;
  if(norm(b) &lt; norm(c)) return +2;
  return -2;
}

inline Point normalize(const Point &amp;v) { return v / norm(v); }

inline Point normal(const Point &amp;v) {
  return v * Point(cos(PI / 2), sin(PI / 2));
}

// [0, pi]
Scalar arg(const Point &amp;a, const Point &amp;b) {
  return acos(dot(a, b) / norm(a) / norm(b));
}

// triangle, arg a
Scalar arg(Scalar a, Scalar b, Scalar c) {
  return acos((b * b + c * c - a * a) / (2 * b * c));
}

// Sarrus
Scalar area3(const Point &amp;a, const Point &amp;b) {
  return abs(a.X * b.Y - a.Y * b.X) / 2;
}

// Heron's formula
Scalar area3(Scalar a, Scalar b, Scalar c) {
  Scalar s = (a + b + c) / 2;
  return sqrt(s * (s - a) * (s - b) * (s - c));
}

Scalar dist(const Line &amp;line, const Point &amp;p) {
  return cross(p - line.first, line.second - line.first) /
         abs(line.second - line.first);
}

Scalar dist(const Segment &amp;segment, const Point &amp;p) {
  if(sign(dot(segment.first - segment.second, p - segment.second)) *
         sign(dot(segment.second - segment.first, p - segment.first)) &gt;=
     0)
    return dist(Line(segment.first, segment.second), p);
  else
    return min(norm(p - segment.first), norm(p - segment.second));
}

Scalar dist(const Segment &amp;a, const Segment &amp;b) {
  return min({
      dist(a, b.first),
      dist(a, b.second),
      dist(b, a.first),
      dist(b, a.second),
  });
}

bool isCrossing(const Segment &amp;a, const Segment &amp;b) {
  return ccw(a.first, a.second, b.first) * ccw(a.first, a.second, b.second) &lt;=
             0 &amp;&amp;
         ccw(b.first, b.second, a.first) * ccw(b.first, b.second, a.second) &lt;=
             0;
}

Point intersection(const Line &amp;a, const Line &amp;b) {
  return a.first +              //
         (a.second - a.first) * //
             cross(a.first - b.first, b.second - b.first) *
             cross(a.first - a.second, b.second - b.first);
}

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Geometory Circle Library</span></p>

<pre><code>/// --- Geometory Circle Library {{{ ///
// center, radius
using Circle = pair&lt; Point, Scalar &gt;;

// -1 : 0 share (outside)
//  1 : 0 share (B in A)
//  2 : 0 share (A in B)
// -3 : 1 share (outside)
//  3 : 1 share (B in A)
//  4 : 1 share (A in B)
//  0 : 2 share
int cpr(const Circle &amp;a, const Circle &amp;b) {
  Scalar d = norm(a.first - b.first);
  if(a.second + b.second + EPS &lt; d) return -1;
  if(b.second + d + EPS &lt; a.second) return 1;
  if(a.second + d + EPS &lt; b.second) return 2;
  if(abs(a.second + b.second - d) &lt; EPS) return -3;
  if(abs(b.second + d - a.second) &lt; EPS) return 3;
  if(abs(a.second + d - b.second) &lt; EPS) return 4;
  return 0;
}

vector&lt; Point &gt; intersections(const Circle &amp;a, const Circle &amp;b) {
  vector&lt; Point &gt; res;
  // normalize(b-a) * R_A
  Point x = a.second * normalize(b.first - a.first);
  if(abs(cpr(a, b)) &gt;= 3) {
    res.emplace_back(a.first + x);
  } else if(cpr(a, b) == 0) {
    Scalar s = arg(b.second, norm(b.first - a.first), a.second);
    res.emplace_back(a.first + x * Point(cos(s), sin(s)));
    res.emplace_back(a.first + x * Point(cos(-s), sin(-s)));
  }
  return res;
}

vector&lt; Point &gt; intersections(const Circle &amp;a, const Line &amp;line) {
  vector&lt; Point &gt; res;
  Point n = normal(line.first - line.second);
  Point p = intersection(line, Line(a.first, a.first + n));
  Scalar d = norm(a.first - p);
  if(abs(d - a.second) &lt; EPS) {
    res.emplace_back(p);
  } else if(abs(d) &lt; a.second) {
    Scalar len = sqrt(a.second * a.second - d * d);
    Point share = len * normalize(line.first - line.second);
    res.emplace_back(p + share);
    res.emplace_back(p - share);
  }
  return res;
}

inline Scalar area(const Circle &amp;a) { return PI * a.second * a.second; }

Scalar shareArea(Circle a, Circle b) {
  Scalar d = norm(a.first - b.first);
  if(a.second + b.second &lt; d + EPS) return 0;
  if(a.second &lt; b.second) swap(a, b);
  if(b.second + d &lt; a.second + EPS) return area(b);
  Scalar s1 = arg(b.second, a.second, d), s2 = arg(a.second, b.second, d);
  Scalar tri2 =
      (a.second * a.second * sin(s1 * 2) + b.second * b.second * sin(s2 * 2)) /
      2;
  return a.second * a.second * s1 + b.second * b.second * s2 - tri2;
}

inline Line ajacentLine(const Circle &amp;c, const Point &amp;p) {
  return Line(p, p + normal(p - c.first));
}

// the tangentLine of c passing p
vector&lt; Line &gt; tangentLines(const Circle &amp;c, const Point &amp;p) {
  vector&lt; Line &gt; res;
  Scalar d = norm(p - c.first);
  if(abs(d - c.second) &lt; EPS)
    res.emplace_back(ajacentLine(c, p));
  else if(c.second &lt; d) {
    Point a = c.first + c.second * normalize(p - c.first);
    vector&lt; Point &gt; b = intersections(
        Circle(c.first, norm(c.first - p)), Line(a, a + normal(c.first - p)));
    for(size_t i = 0; i &lt; b.size(); i++) {
      res.emplace_back(p, c.first + c.second * normalize(b[i] - c.first));
    }
  }
  return res;
}

vector&lt; Line &gt; commonTangentLines(Circle a, Circle b) {
  vector&lt; Line &gt; res;
  if(a.second + EPS &lt; b.second) swap(a, b);
  if(norm(a.first - b.first) &lt; EPS) return res;

  Point p = a.first + (b.first - a.first) * a.second / (a.second + b.second);
  if(norm(a.first - p) + EPS &gt; a.second) res = tangentLines(a, p);
  if(abs(a.second - b.second) &lt; EPS) {
    Point n = normal(normalize(b.first - a.first) * a.second);
    res.emplace_back(a.first + n, b.first + n);
    res.emplace_back(a.first - n, b.first - n);
  } else {
    Point q = a.first + (b.first - a.first) * a.second / (a.second - b.second);
    if(abs(a.first - q) + EPS &gt; a.second) {
      vector&lt; Line &gt; tmp = tangentLines(a, q);
      res.insert(begin(res), begin(tmp), end(tmp));
    }
  }
  return res;
}

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Geometory Polygon Library</span></p>

<pre><code>/// --- Geometory Polygon Library {{{ ///
// ok for either ccw or cw
Scalar area(const Polygon &amp;poly) {
  if(poly.size() &lt; 3) return 0;
  Scalar res = cross(poly[poly.size() - 1], poly[0]);
  for(size_t i = 0; i &lt; poly.size() - 1; i++) {
    res += cross(poly[i], poly[i + 1]);
  }
  return abs(res) / 2;
}

//  0 : outside
//  1 : inside
// -1 : on vertex
// -2 : on line
int inside(const Polygon &amp;poly, const Point &amp;p) {
  int cnt = 0;
  for(size_t i = 0; i &lt; poly.size(); i++) {
    size_t ii = i, jj = (i + 1) % poly.size();
    if(norm(poly[i] - p) &lt; EPS) return -1;
    if(poly[ii].Y &gt; poly[jj].Y) swap(ii, jj);
    if(poly[ii].Y - EPS &lt; p.Y &amp;&amp; p.Y &lt; poly[jj].Y + EPS) {
      if(abs(poly[ii].Y - poly[jj].Y) &lt; EPS) { // parallel
        if(poly[ii].X &gt; poly[jj].X) swap(ii, jj);
        if(poly[ii].X - EPS &lt; p.X &amp;&amp; p.X &lt; poly[jj].X + EPS) return -2;
      } else {
        Point q =
            intersection(Line(poly[ii], poly[jj]), Line(p, p + Point(1, 0)));
        if(p.X &lt; q.X &amp;&amp; p.Y &gt; poly[ii].Y + EPS) cnt++; // count only upside
      }
    }
  }
  return cnt &amp; 1;
}

// param ccwConvex must be ccw and convex
Scalar caliper(const Polygon &amp;ccwConvex) {
  constexpr auto comp = [](Point a, Point b) {
    return a.X == b.X ? a.Y &lt; b.Y : a.X &lt; b.X;
  };
  size_t i, j;
  for(size_t k = 0; k &lt; ccwConvex.size(); k++) {
    if(comp(ccwConvex[i], ccwConvex[k])) j = k;
    if(!comp(ccwConvex[j], ccwConvex[k])) i = k;
  }
  Scalar res = 0;
  size_t si = i, sj = j;
  while(i != si || j != sj) {
    res = max(res, norm(ccwConvex[i] - ccwConvex[j]));
    if(cross(ccwConvex[(i + 1) % ccwConvex.size()] - ccwConvex[i],
             ccwConvex[(j + 1) % ccwConvex.size()] - ccwConvex[j]) &lt; 0)
      i = (i + 1) % ccwConvex.size();
    else
      j = (j + 1) % ccwConvex.size();
  }
  return res;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">Graham Scan - Polar Sort - Library</span></p>

<pre><code>// require Geometory Library!
/// --- Graham Scan - Polar Sort - Library {{{ ///

// make ConvexHull

// if there are 3 points on line,
// just guaranteed that point on hull is scanned exactly;
// if on Line of Hull, sometimes scanned as on Hull.
struct GrahamScan {
  Polygon poly;
  vector&lt; size_t &gt; ids;
  vector&lt; size_t &gt; hull;

  void add(Point p) { poly.emplace_back(p); }

  int operator[](int i) {
    return hull[(i % hull.size() + hull.size()) % hull.size()];
  }

  void scan() {
    ids.resize(poly.size());
    iota(begin(ids), end(ids), 0);

    size_t startID = 0;
    for(size_t i = 1; i &lt; poly.size(); i++) {
      if(make_pair(poly[startID].X, poly[startID].Y) &gt;
         make_pair(poly[i].X, poly[i].Y))
        startID = i;
    }
    swap(ids[0], ids[startID]);

    sort(begin(ids) + 1, end(ids), [&amp;](int a, int b) {
      Point p1 = poly[a] - poly[ids[0]];
      Point p2 = poly[b] - poly[ids[0]];
      // p1.y / p1.x &lt; p2.y / p2.x
      double ev = p1.Y * p2.X - p2.Y * p1.X;
      return abs(ev) &lt; EPS ? norm(p1) &lt; norm(p2) : ev &lt; 0;
    });

    hull.emplace_back(ids[0]);
    for(size_t i = 1; i &lt;= poly.size(); i++) {
      size_t ii = i % poly.size();
      while(hull.size() &gt;= 2 &amp;&amp;
            ccw(poly[hull[hull.size() - 2]], poly[hull[hull.size() - 1]],
                poly[ids[ii]]) == -1)
        hull.pop_back();
      hull.emplace_back(ids[ii]);
    }

    hull.pop_back();
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Biconnected Component Decomposition</span></p>

<pre><code>// NOTE : 二重連結成分分解
/// --- Biconnected Component Decomposition {{{ ///

struct Biconnected {
  int n;
  vector&lt; vector&lt; int &gt; &gt; g;
  vector&lt; int &gt; low, ord, used;
  vector&lt; vector&lt; pair&lt; int, int &gt; &gt; &gt; comps;
  int id = 0;
  vector&lt; pair&lt; int, int &gt; &gt; tmp;
  Biconnected(vector&lt; vector&lt; int &gt; &gt; g)
      : n(g.size()), g(g), low(n), ord(n), used(n) {
    for(int i = 0; i &lt; n; i++)
      if(!used[i]) dfs(i);
  }

private:
  void dfs(int i, int p = -1) {
    used[i] = 1;
    ord[i] = low[i] = id++;
    for(int j : g[i])
      if(j != p) {
        pair&lt; int, int &gt; e(min(i, j), max(i, j));
        if(used[j]) {
          if(ord[i] &gt; ord[j]) tmp.emplace_back(e);
          low[i] = min(low[i], ord[j]);
        } else {
          tmp.emplace_back(e);
          dfs(j, i);
          low[i] = min(low[i], low[j]);
          if(low[j] &gt;= ord[i]) {
            comps.push_back({});
            while(1) {
              pair&lt; int, int &gt; ne = tmp.back();
              comps.back().emplace_back(ne);
              tmp.pop_back();
              if(e == ne) break;
            }
          }
        }
      }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Biedge Component Decomposition Libary</span></p>

<pre><code>// !! require Lowlink !!
// NOTE : 二辺連結成分分解
// Biedge(built-lowlink)
// Biedge(graph)
// NOTE : Biedge.tree, .comp
/// --- Biedge Component Decomposition Libary {{{ ///

struct Biedge {
  Lowlink lowlink;
  vector&lt; int &gt; comp;
  vector&lt; vector&lt; int &gt; &gt; tree;

  Biedge(Lowlink lowlink) : lowlink(lowlink) { decomposite(); }
  Biedge(vector&lt; vector&lt; int &gt; &gt; g) : lowlink(g) {
    lowlink.build();
    decomposite();
  }

  vector&lt; int &gt; used;

private:
  void decomposite() {
    int n = lowlink.n;

    tree.resize(n);
    used.resize(n, 0);
    comp.resize(n, -1);

    int gid = 0;
    for(int i = 0; i &lt; n; i++)
      if(!used[i]) dfs(gid++, i, -1);

    tree.resize(gid);
  }

  void dfs(int gid, int i, int p) {
    used[i] = 1;
    comp[i] = gid;
    for(auto edge : lowlink.g[i]) {
      int j = edge.to;
      int idx = edge.idx;
      if(j == p) continue;
      if(lowlink.isBridge[idx]) {
        if(used[j]) {
          tree[gid].emplace_back(comp[j]);
          tree[comp[j]].emplace_back(gid);
        }
      } else if(!used[j]) {
        dfs(gid, j, i);
      }
    }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Doubilng Tree Library</span></p>

<pre><code>// DoublingTree ( &lt;graph&gt; , initial? )
// set (i, val) or assign ( &lt;data&gt; )
// WARN : build(root = 0) !!!
//     or dfs(roots) &amp; init() !!
// lca (a, b)
// query(hi, a, hi_inclusive?)
/// --- Doubilng Tree Library {{{ ///

template &lt; class Monoid &gt;
struct DoublingTree {
  using T = typename Monoid::T;
  int n, logn;
  vector&lt; vector&lt; int &gt; &gt; tree;
  vector&lt; int &gt; depth; // 0-indexed
  // [logn][n]
  vector&lt; vector&lt; int &gt; &gt; par;
  vector&lt; vector&lt; T &gt; &gt; dat;
  int log(int n) {
    int h = 1;
    while((1 &lt;&lt; h) &lt; n) h++;
    return h;
  }
  DoublingTree(int n, const T &amp;initial = Monoid::identity())
      : n(n),
        logn(log(n)),
        tree(n),
        depth(n),
        par(logn, vector&lt; int &gt;(n)),
        dat(logn, vector&lt; T &gt;(n, initial)) {}
  template &lt; class InputIter,
             class = typename iterator_traits&lt; InputIter &gt;::value_type &gt;
  DoublingTree(InputIter first, InputIter last,
               const T &amp;initial = Monoid::identity())
      : DoublingTree(distance(first, last), initial) {
    copy(first, last, begin(tree));
  }
  DoublingTree(const vector&lt; vector&lt; int &gt; &gt; &amp;tree,
               const T &amp;initial = Monoid::identity())
      : DoublingTree(begin(tree), end(tree), initial) {}
  void set(int i, const T &amp;val) { dat[0][i] = val; }
  template &lt; class InputIter,
             class = typename iterator_traits&lt; InputIter &gt;::value_type &gt;
  void assign(InputIter first, InputIter last) {
    assert(distance(first, last) &lt;= n);
    copy(first, last, begin(dat[0]));
  }
  void build(const vector&lt; int &gt; &amp;roots) {
    for(int root : roots) dfs(root);
    init();
  }
  void build(int root = 0) {
    dfs(root);
    init();
  }
  void init() {
    for(int k = 1; k &lt; logn; k++) {
      for(int i = 0; i &lt; n; i++) {
        int p = par[k - 1][i];
        if(p == -1) {
          par[k][i] = -1;
          continue;
        }
        dat[k][i] = Monoid::op(dat[k - 1][p], dat[k - 1][i]);
        par[k][i] = par[k - 1][p];
      }
    }
  }
  void dfs(int i, int p = -1, int d = 0) {
    depth[i] = d;
    par[0][i] = p;
    for(int j : tree[i])
      if(j != p) {
        dfs(j, i, d + 1);
      }
  }

public:
  int lca(int a, int b) {
    if(depth[a] &lt; depth[b]) swap(a, b);
    for(int k = logn - 1; k &gt;= 0; k--) {
      int na = par[k][a];
      if(na == -1 || depth[na] &lt; depth[b]) continue;
      a = na;
    }
    if(a == b) return a;
    for(int k = logn - 1; k &gt;= 0; k--) {
      int na = par[k][a];
      int nb = par[k][b];
      if(na == nb) continue;
      a = na, b = nb;
    }
    return par[0][a];
  }
  T query(int hi, int a, bool inclusive = true) {
    T res = Monoid::identity();
    for(int k = logn - 1; k &gt;= 0; k--) {
      int na = par[k][a];
      if(na == -1 || depth[na] &lt; depth[hi]) continue;
      res = Monoid::op(dat[k][a], res);
      a = na;
    }
    if(inclusive) res = Monoid::op(dat[0][hi], res);
    return res;
  }
};

/// }}}--- ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

DoublingTree&lt; RangeSum &gt; eca(N);
</code></pre>

<p><span class="lib-title">BipartiteMatching Library</span></p>

<pre><code>/// --- BipartiteMatching Library {{{ ///
struct BipartiteMatching {
  int n;
  vector&lt; vector&lt; int &gt; &gt; graph;

  BipartiteMatching(int n) : n(n), graph(n) {}
  void addEdge(int a, int b) {
    graph[a].emplace_back(b);
    graph[b].emplace_back(a);
  }

  vector&lt; int &gt; used;
  vector&lt; int &gt; match;

  // max flow
  int solve() {
    match = vector&lt; int &gt;(n, -1);
    int flow = 0;
    for(int i = 0; i &lt; n; i++) {
      if(match[i] &lt; 0) {            ///
        used = vector&lt; int &gt;(n, 0); ///
        if(dfs(i)) flow++;
      }
    }
    return flow;
  }

private:
  bool dfs(int v) {
    if(used[v]) return false; ///
    used[v] = 1;
    for(int u : graph[v])
      if(match[u] &lt; 0 || dfs(match[u])) {
        match[v] = u;
        match[u] = v;
        return true;
      }
    return false;
  }
};
/// }}}--- ///
</code></pre>

<p><span class="lib-title">Dinic Libary</span></p>

<pre><code>/// --- Dinic Libary {{{ ///
// solve max flow

struct Dinic {
  struct Edge {
    int from, to;
    ll cap, rev;
    int To(int i) { return from == i ? to : from; }
    ll&amp; Cap(int i) { return from == i ? cap : rev; }
    ll&amp; Rev(int i) { return from == i ? rev : cap; }
  };

  int n;
  vector&lt; Edge &gt; edges;
  vector&lt; vector&lt; int &gt; &gt; g;
  ll inf;
  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}

  void addEdge(int a, int b, ll cap, int i = -1, bool undirected = false) {
    if(i == -1) i = edges.size();
    edges.resize(max(i + 1, (int) edges.size()));
    edges[i] = (Edge){a, b, cap, undirected ? cap : 0};
    g[a].emplace_back(i);
    g[b].emplace_back(i);
  }

  ll solve(int s, int t) {
    vector&lt; int &gt; level(n);
    ll flow = 0;
    while(bfs(s, level), level[t] &gt; 0) {
      ll newflow = dfs(s, t, inf, level);
      if(newflow == 0) break;
      flow += newflow;
      if(flow &gt;= inf) return inf;
    }
    return flow;
  }

private:
  void bfs(int s, vector&lt; int &gt;&amp; level) {
    fill(begin(level), end(level), -1);
    queue&lt; int &gt; q;
    q.emplace(s);
    level[s] = 0;
    while(q.size()) {
      int i = q.front();
      q.pop();
      for(int idx : g[i]) {
        Edge edge = edges[idx];
        if(level[edge.To(i)] == -1 &amp;&amp; edge.Cap(i) &gt; 0) {
          level[edge.To(i)] = level[i] + 1;
          q.emplace(edge.To(i));
        }
      }
    }
  }

  ll dfs(int i, int t, ll flow, vector&lt; int &gt; const&amp; level) {
    if(i == t) return flow;
    for(int idx : g[i]) {
      Edge&amp; edge = edges[idx];
      if(edge.Cap(i) &gt; 0 &amp;&amp; level[edge.To(i)] &gt; level[i]) {
        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);
        if(newflow == 0) continue;
        edge.Cap(i) -= newflow;
        edge.Rev(i) += newflow;
        return newflow;
      }
    }
    return 0;
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Max Flow with FordFulkerson Library</span></p>

<pre><code>/// --- Max Flow with FordFulkerson Library {{{ ///

// Ford-Fulkerson
// O(FV)
struct Ford {
  struct Edge {
    int from, to;
    ll cap, rev;
    int To(int i) { return from == i ? to : from; }
    ll&amp; Cap(int i) { return from == i ? cap : rev; }
    ll&amp; Rev(int i) { return from == i ? rev : cap; }
  };
  int n;
  vector&lt; Edge &gt; edges;
  vector&lt; vector&lt; int &gt; &gt; g;
  ll inf;
  Ford(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}

  void addEdge(int a, int b, ll cap, int i = -1, bool undirected = false) {
    if(i == -1) i = edges.size();
    edges.resize(max(i + 1, (int) edges.size()));
    edges[i] = (Edge){a, b, cap, undirected ? cap : 0};
    g[a].emplace_back(i);
    g[b].emplace_back(i);
  }

  ll solve(int s, int t) {
    ll flow = 0;
    while(1) {
      vector&lt; int &gt; used(n, 0);
      ll x = dfs(used, s, t, inf);
      if(x == 0) break;
      flow += x;
      if(flow &gt;= inf) return inf;
    }
    return flow;
  }

private:
  ll dfs(vector&lt; int &gt;&amp; used, int i, int t, ll x) {
    if(i == t) return x;
    used[i] = 1;
    for(int idx : g[i])
      if(!used[edges[idx].To(i)] &amp;&amp; edges[idx].Cap(i) &gt; 0) {
        Edge&amp; edge = edges[idx];
        ll d = dfs(used, edge.To(i), t, min(x, edge.Cap(i)));
        if(d == 0) continue; ////
        edge.Cap(i) -= d;
        edge.Rev(i) += d;
        return d;
      }
    return 0;
  }
};

/// }}}--- ///

// const int N = 2e6;
// Ford flow(N, 1e18);
</code></pre>

<p><span class="lib-title">MinCostFlow Library</span></p>

<pre><code>/// --- MinCostFlow Library {{{ ///
struct MinCostFlow {
  struct Edge {
    int to;
    ll cap, cost;
    size_t rev;
  };
  int n;
  vector&lt; vector&lt; Edge &gt; &gt; graph;
  vector&lt; ll &gt; dist;
  vector&lt; int &gt; prevv, previ;
  ll inf;
  MinCostFlow(int n, ll inf)
      : n(n), graph(n), dist(n), prevv(n), previ(n), inf(inf) {}
  void addEdge(int a, int b, ll cap, ll cost, int undirected = 0) {
    graph[a].emplace_back((Edge){b, cap, cost, graph[b].size()});
    graph[b].emplace_back(
        (Edge){a, undirected ? cap : 0, -cost, graph[a].size() - 1});
  }
  ll solve(int s, int t, ll f) {
    ll res = 0;
    while(f &gt; 0) {
      fill(begin(dist), end(dist), inf);
      dist[s] = 0;
      bool update = 1;
      // Bellman-Ford
      while(update) {
        update = 0;
        for(int v = 0; v &lt; n; v++) {
          if(dist[v] == inf) continue;
          for(size_t i = 0; i &lt; graph[v].size(); i++) {
            Edge &amp;edge = graph[v][i];
            if(edge.cap &gt; 0 &amp;&amp; dist[edge.to] &gt; dist[v] + edge.cost) {
              dist[edge.to] = dist[v] + edge.cost;
              prevv[edge.to] = v;
              previ[edge.to] = i;
              update = 1;
            }
          }
        }
      }
      //
      if(dist[t] == inf) return -1;
      ll d = f;
      for(int v = t; v != s; v = prevv[v]) {
        d = min(d, graph[prevv[v]][previ[v]].cap);
      }
      f -= d;
      res += d * dist[t];
      for(int v = t; v != s; v = prevv[v]) {
        Edge &amp;edge = graph[prevv[v]][previ[v]];
        edge.cap -= d;
        graph[v][edge.rev].cap += d;
      }
    }
    return res;
  }
};

/// }}}--- ///

// const int N = 100000;
// ll inf = 1e18;
// MinCostFlow ecas(N, inf);
</code></pre>

<p><span class="lib-title">HL-Decomposition Library</span></p>

<pre><code>// query(hi, lo, func, inclusive?)
// hld[i] : index on sequence
// WARN : build after adding edges!
/// --- HL-Decomposition Library {{{ ///

struct HLD {
  int n;
  vector&lt; int &gt; head;
  vector&lt; int &gt; sz;
  vector&lt; int &gt; dep;
  vector&lt; int &gt; par;
  vector&lt; int &gt; vid;
  int id = 0;
  vector&lt; vector&lt; int &gt; &gt; g; // tree
  HLD(int n) : n(n), head(n), sz(n), dep(n), par(n), vid(n), g(n) {}
  HLD(vector&lt; vector&lt; int &gt; &gt; g, int root = 0) : HLD(g.size()) {
    this-&gt;g = g;
    build(root);
  }
  int operator[](int i) { return vid[i]; }
  void addEdge(int a, int b) {
    g[a].emplace_back(b);
    g[b].emplace_back(a);
  }
  void build(int root = 0) {
    head[root] = root;
    dfs0(root, -1, 0);
    dfs1(root, -1);
  }
  int lca(int a, int b) {
    while(1) {
      if(vid[a] &gt; vid[b]) swap(a, b);
      if(head[a] == head[b]) return a;
      b = par[head[b]];
    }
  }
  void query(int hi, int lo, function&lt; void(int, int) &gt; f,
             bool inclusive = true) {
    while(lo != -1 &amp;&amp; dep[lo] &gt;= dep[hi]) {
      int nex = max(vid[head[lo]], vid[hi]);
      f(nex + (nex == vid[hi] &amp;&amp; !inclusive), vid[lo] + 1);
      lo = par[head[lo]];
    }
  }

private:
  void dfs0(int i, int p, int d) {
    par[i] = p;
    sz[i] = 1;
    dep[i] = d;
    for(int &amp;j : g[i])
      if(j != p) {
        dfs0(j, i, d + 1);
        sz[i] += sz[j];
        if(sz[j] &gt; sz[g[i][0]]) {
          swap(g[i][0], j);
        }
      }
  }
  void dfs1(int i, int p) {
    vid[i] = id++;
    for(int j : g[i])
      if(j != p) {
        head[j] = j == g[i][0] ? head[i] : j;
        dfs1(j, i);
      }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Lowlink Library</span></p>

<pre><code>// Lowlink(UndirectedGraph)
// or use addEdge
// must build()
/// --- Lowlink Library {{{ ///

struct Lowlink {
  struct Edge {
    int to, idx;
  };
  int n;
  int edgeSize = 0;
  vector&lt; vector&lt; Edge &gt; &gt; g;
  vector&lt; int &gt; ord, low;

  vector&lt; int &gt; used;
  vector&lt; int &gt; isBridge, isArticulation;
  Lowlink(int n) : n(n), g(n), ord(n), low(n) {}
  Lowlink(vector&lt; vector&lt; int &gt; &gt; ig) : n(ig.size()), g(n), ord(n), low(n) {
    for(int from = 0; from &lt; n; from++)
      for(int to : ig[from])
        if(from &lt; to) addEdge(from, to);
  }

  void addEdge(int a, int b) {
    g[a].emplace_back((Edge){b, edgeSize});
    g[b].emplace_back((Edge){a, edgeSize});
    edgeSize++;
  }

  void build() {
    used.resize(n, 0);
    isBridge.resize(edgeSize, 0);
    isArticulation.resize(n, 0);

    int k = 0;
    dfs(0, -1, k);
  }

private:
  void dfs(int i, int p, int &amp;k) {
    used[i] = 1;
    ord[i] = low[i] = k++;
    isArticulation[i] = 0;
    int DFSTreeDegree = 0;
    for(Edge edge : g[i]) {
      int j = edge.to;
      int idx = edge.idx;
      if(j == p) continue;
      if(!used[j]) {
        // on dfs-tree
        DFSTreeDegree++;
        dfs(j, i, k);
        low[i] = min(low[i], low[j]);
        isBridge[idx] = ord[i] &lt; low[j];
        if(p != -1 &amp;&amp; ord[i] &lt;= low[j]) {
          isArticulation[i] = 1;
        }
      } else {
        low[i] = min(low[i], ord[j]);
      }
    }
    if(p == -1 &amp;&amp; DFSTreeDegree &gt; 1) {
      isArticulation[i] = 1;
    }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">MSTArborescence Library</span></p>

<pre><code>// require SCC Libary!
// int MSTArborescence(WeightedDirectedGraph, int root)
/// --- MSTArborescence Library {{{ ///

ll MSTArborescence(vector&lt; vector&lt; pair&lt; int, int &gt; &gt; &gt; &amp;graph, int start,
                   ll sum = 0) {
  int n = graph.size();

  vector&lt; int &gt; rev(n, -1);
  vector&lt; ll &gt; weight(n, INF);
  for(int idx = 0; i &lt; n; i++) {
    for(auto &amp;e : graph[idx]) {
      if(se(e) &lt; weight[fi(e)]) {
        weight[fi(e)] = se(e);
        rev[fi(e)] = idx;
      }
    }
  }

  SCC scc(n);
  for(int i = 0; i &lt; n; i++) {
    if(start == i) continue;
    scc.addEdge(rev[i], i);
    sum += weight[i];
  }
  vector&lt; vector&lt; int &gt; &gt; renew;
  scc.decomposite(renew);
  if(renew.size() == n) return sum;
  vector&lt; vector&lt; pair&lt; int, int &gt; &gt; &gt; fixed(renew.size());
  for(int i = 0; i &lt; n; i++) {
    for(P &amp;e : graph[i]) {
      if(scc[i] == scc[fi(e)]) continue;
      fixed[scc[i]].emplace_back(scc[fi(e)], se(e) - weight[fi(e)]);
    }
  }
  return MSTArborescence(fixed, scc[start], sum);
}

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Strongly Connected Component</span></p>

<pre><code>// SCC(UnWeightedGraph)
// must build(renew)
/// --- Strongly Connected Component {{{ ///

struct SCC {
  int n;
  vector&lt; vector&lt; int &gt; &gt; g, rev;
  vector&lt; int &gt; topo;
  vector&lt; int &gt; used;
  vector&lt; int &gt; comp;
  SCC(int n) : n(n), g(n), rev(n) {}
  SCC(vector&lt; vector&lt; int &gt; &gt; ig) : n(ig.size()), g(n), rev(n) {
    for(int from = 0; from &lt; n; from++)
      for(int to : ig[from]) addEdge(from, to);
  }
  void addEdge(int a, int b) {
    g[a].emplace_back(b);
    rev[b].emplace_back(a);
  }
  int operator[](int i) { return comp[i]; }
  void build(vector&lt; vector&lt; int &gt; &gt; &amp;renew) {
    used.resize(n, 0);
    comp.resize(n, -1);
    for(int i = 0; i &lt; n; i++)
      if(!used[i]) dfs1(i);
    reverse(begin(topo), end(topo));
    int k = 0;
    for(int i : topo)
      if(comp[i] == -1) dfs2(i, k++);

    renew.resize(k);
    set&lt; pair&lt; int, int &gt; &gt; connect;
    for(int i = 0; i &lt; n; i++) {
      for(int j : g[i]) {
        int x = comp[i], y = comp[j];
        if(x == y) continue;
        if(connect.count(make_pair(x, y))) continue;
        connect.emplace(x, y);
        renew[x].emplace_back(y);
      }
    }
  }

private:
  void dfs1(int i) {
    if(used[i]) return;
    used[i] = 1;
    for(int j : g[i]) dfs1(j);
    topo.emplace_back(i);
  }
  void dfs2(int i, int num) {
    if(comp[i] != -1) return;
    comp[i] = num;
    for(int j : rev[i]) dfs2(j, num);
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">FFT with long double Library</span></p>

<pre><code>/// --- FFT with long double Library {{{ ///

using C = complex&lt; long double &gt;;
using VC = vector&lt; C &gt;;

// using FFT
VC dft(VC a, bool inverse = false) {
  constexpr long double PI = 3.14159265358979323;
  int n = a.size();
  if(n == 1) return a;
  VC odd(n / 2), even(n / 2);
  for(int i = 0; i &lt; n / 2; i++) odd[i] = a[i * 2 + 1];
  for(int i = 0; i &lt; n / 2; i++) even[i] = a[i * 2];
  odd = dft(odd);
  even = dft(even);
  C zeta = C(cos(2 * PI / n), sin(2 * PI / n));
  if(inverse) zeta = C(1, 0) / zeta;
  C powZeta = C(1, 0);
  for(int _i = 0; _i &lt; n; _i++) {
    int i = _i;
    if(inverse) i = (n - i) % n;
    // powZeta = pow(zeta, i)
    a[_i] = even[i % (n / 2)] + powZeta * odd[i % (n / 2)]; ////
    if(inverse) a[_i] /= n;
    powZeta *= zeta;
  }
  return a;
}

// convolution
VC conv(VC a, VC b) {
  int m = a.size();
  int n = 1;
  while(n &lt; m) n &lt;&lt;= 1;
  a.resize(n, C(0, 0));
  b.resize(n, C(0, 0));
  a = dft(a);
  b = dft(b);
  VC c(n);
  for(int i = 0; i &lt; n; i++) c[i] = a[i] * b[i];
  return dft(c, true);
}

/// }}}--- ///
</code></pre>

<p><span class="lib-title">GaussJordan</span></p>

<pre><code>using Vec = vector&lt; double &gt;;
using Mat = vector&lt; Vec &gt;;
/// --- GaussJordan {{{ ///
Vec gaussJordan(Mat mat, Vec v, double eps = 1e-9) {
  int n = mat.size();
  assert(n == (int) mat[0].size() &amp;&amp; n == (int) v.size());
  for(int i = 0; i &lt; (int) v.size(); i++) {
    mat[i].emplace_back(v[i]);
  }
  for(int i = 0; i &lt; n; i++) {
    int pivot = i;
    for(int j = i + 1; j &lt; n; j++) {
      if(abs(mat[pivot][i] &lt; abs(mat[j][i]))) pivot = j;
    }
    if(mat[pivot][i] &lt; eps) return Vec();
    swap(mat[i], mat[pivot]);
    for(int j = i + 1; j &lt;= n; j++) {
      mat[i][j] /= mat[i][i];
    }
    for(int j = 0; j &lt; n; j++)
      if(j != i) {
        for(int k = i + 1; k &lt;= n; k++) {
          mat[j][k] -= mat[j][i] * mat[i][k];
        }
      }
  }
  for(int i = 0; i &lt; n; i++) v[i] = mat[i][n];
  return v;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">isPrime</span></p>

<pre><code>/// --- isPrime {{{ ///

bool isPrime(int n) {
  if(n &lt; 2) return false;
  for(int i = 2; i * i &lt;= n; i++) {
    if(n % i == 0) return false;
  }
  return true;
}

/// }}}--- ///
</code></pre>

<p><span class="lib-title">divisor</span></p>

<pre><code>// O(N^.5)
/// --- divisor {{{ ///
vector&lt; ll &gt; divisor(ll n) {
  vector&lt; ll &gt; res;
  for(ll i = 1; i * i &lt;= n; i++) {
    if(n % i == 0) {
      res.emplace_back(i);
      if(i != n / i) res.emplace_back(n / i);
    }
  }
  return res;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">primeFactors</span></p>

<pre><code>// O(N^.5)
/// --- primeFactors {{{ ///
map&lt; ll, int &gt; primeFactors(ll n) {
  map&lt; ll, int &gt; res;
  for(ll i = 2; i * i &lt;= n; i++) {
    while(n % i == 0) n /= i, res[i]++;
  }
  if(n != 1) res[n] = 1;
  return res;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">phi</span></p>

<pre><code>// O(N^.5)
/// --- phi {{{ ///
ll phi(ll n) {
  ll res = n;
  for(ll i = 2; i * i &lt;= n; i++) {
    if(n % i == 0) {
      res = res / i * (i - 1);
      while(n % i == 0) n /= i;
    }
  }
  if(n != 1) res = res / n * (n - 1);
  return res;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">phi2</span></p>

<pre><code>// O(N log log N)
/// --- phi2 {{{ ///
vector&lt; int &gt; phi2(int n) {
  n++;
  vector&lt; int &gt; euler(n);
  for(int i = 0; i &lt; n; i++) euler[i] = i;
  for(int i = 2; i &lt; n; i++) {
    if(euler[i] == i) {
      for(int j = i; j &lt; n; j += i) euler[j] = euler[j] / i * (i - 1);
    }
  }
  return euler;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">primes</span></p>

<pre><code>/// --- primes {{{ ///
vector&lt; ll &gt; primes(ll n) {
  vector&lt; ll &gt; res;
  for(ll i = 2; i * i &lt;= n; i++) {
    int isp = 1;
    for(ll p : res) {
      if(p * p &gt; i) break;
      if(i % p == 0) isp = 0;
    }
    if(isp) res.emplace_back(p);
  }
  return res;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">math</span></p>

<pre><code>/// --- math {{{ ///
ll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }
ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }
ll extgcd(ll a, ll b, ll &amp;x, ll &amp;y) {
  ll d;
  return b == 0 ? (x = 1, y = 0, a)
                : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);
}
ll modinv(ll a, ll mod = 1e9 + 7) {
  ll x = 0, y = 0;
  extgcd(a, mod, x, y);
  return (x + mod) % mod;
}
ll modpow(ll a, ll b, ll mod = 1e9 + 7) {
  ll r = 1;
  a %= mod;
  while(b) {
    if(b &amp; 1) r = r * a % mod;
    a = a * a % mod;
    b &gt;&gt;= 1;
  }
  return r;
}
/// }}}--- ///
</code></pre>

<p><span class="lib-title">givens</span></p>

<pre><code>using Vec = vector&lt; double &gt;;
using Mat = vector&lt; Vec &gt;;
#define mkrot(x, y, c, s)           \
  {                                 \
    double r = sqrt(x * x + y * y); \
    c = x / r;                      \
    s = y / r;                      \
  }
#define rot(x, y, c, s)        \
  {                            \
    double u = c * x + s * y;  \
    double v = -s * x + c * y; \
    x = u;                     \
    y = v;                     \
  }
Vec givens(Mat A, Vec b) {
  const int n = b.size();
  for(int i = 0; i &lt; n; ++i)
    for(int j = i + 1; j &lt; n; ++j) {
      double c, s;
      mkrot(A[i][i], A[j][i], c, s);
      rot(b[i], b[j], c, s);
      for(int k = i; k &lt; n; k++) rot(A[i][k], A[j][k], c, s);
    }
  for(int i = n - 1; i &gt;= 0; --i) {
    for(int j = i + 1; j &lt; n; ++j) b[i] -= A[i][j] * b[j];
    b[i] /= A[i][i];
  }
  return b;
}
</code></pre>

<p><span class="lib-title">Matrix mult pow Library</span></p>

<pre><code>/// --- Matrix mult pow Library {{{ ///

template &lt; class T &gt;
vector&lt; vector&lt; T &gt; &gt; mult(vector&lt; vector&lt; T &gt; &gt; a, vector&lt; vector&lt; T &gt; &gt; b) {
  assert(a[0].size() == b.size());
  vector&lt; vector&lt; T &gt; &gt; res(a.size(), vector&lt; T &gt;(b[0].size(), 0));
  for(int i = 0; i &lt; a.size(); i++) {
    for(int j = 0; j &lt; b[0].size(); j++) {
      for(int k = 0; k &lt; a[0].size(); k++) {
        res[i][j] += a[i][k] * b[k][j];
      }
    }
  }
}

template &lt; class T &gt;
vector&lt; vector&lt; T &gt; &gt; pow(vector&lt; vector&lt; T &gt; &gt; a, ll k) {
  vector&lt; vector&lt; T &gt; &gt; r(a.size(), vector&lt; T &gt;(a.size(), 0));
  for(size_t i = 0; i &lt; a.size(); i++) r[i][i] = T(1);
  while(k) {
    if(k &amp; 1) r = mult(r, a);
    a = mult(a, a);
    k &gt;&gt;= 1;
  }
  return r;
}

/// }}}--- ///

using Vec = vector&lt; ll &gt;;
using Mat = vector&lt; Vec &gt;;
</code></pre>

<p><span class="lib-title">moebius</span></p>

<pre><code>// O(N^.5)
unordered_map&lt; ll, int &gt; moebius(ll n) {
  unordered_map&lt; ll, int &gt; res;
  vector&lt; ll &gt; primes;
  for(ll i = 2; i * i &lt;= n; i++) {
    if(n % i == 0) primes.emplace_back(i);
  }
  if(n != 1) primes.emplace_back(n);
  int m = primes.size();
  for(int i = 0; i &lt; (1 &lt;&lt; m); i++) {
    int mu = 1;
    ll num = 1;
    for(int j = 0; j &lt; m; j++)
      if(i &amp; (1 &lt;&lt; j)) {
        mu *= -1;
        num *= primes[j];
      }
    res[num] = mu;
  }
  return res;
}
</code></pre>

<p><span class="lib-title">Monoid, M_act examples</span></p>

<pre><code>/// --- Monoid, M_act examples {{{ ///

/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///

// MinAdd m + x
// MinSet m
// SumAdd m * n + x
// SumSet m * n

struct RangeMinAdd {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll, const X &amp;x) { return m + x; }
};

struct RangeMinSet {
  using M = ll;
  using X = RangeMin::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll, const X &amp;) { return m; }
};

struct RangeSumAdd {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;b) { return a + b; }
  static constexpr M identity() { return 0; }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;x) { return m * n + x; }
};

struct RangeSumSet {
  using M = ll;
  using X = RangeSum::T;
  static M op(const M &amp;a, const M &amp;) { return a; }
  static constexpr M identity() { return numeric_limits&lt; M &gt;::min(); }
  static X actInto(const M &amp;m, ll, ll n, const X &amp;) { return m * n; }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Monoid examples</span></p>

<pre><code>/// --- Monoid examples {{{ ///

struct Nothing {
  using T = char;
  using M = char;
  static constexpr T op(const T &amp;, const T &amp;) { return 0; }
  static constexpr T identity() { return 0; }
  template &lt; class X &gt;
  static constexpr X actInto(const M &amp;, ll, ll, const X &amp;x) {
    return x;
  }
};

struct RangeMin {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return min(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::max(); }
};

struct RangeMax {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return max(a, b); }
  static constexpr T identity() { return numeric_limits&lt; T &gt;::min(); }
};

struct RangeSum {
  using T = ll;
  static T op(const T &amp;a, const T &amp;b) { return a + b; }
  static constexpr T identity() { return 0; }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Montgomery Library</span></p>

<pre><code>/// --- Montgomery Library {{{ ///

template &lt; int mod = (int) 1e9 + 7 &gt;
struct Montgomery {
  int modlen = 64 - __builtin_clzll(mod);
  ll r2 = (1ll &lt;&lt; (modlen * 2)) % mod;
  ll mask = (1 &lt;&lt; modlen) - 1;
  ll nr;
  Montgomery() {
    nr = 0;
    int t = 0;
    int vi = 1;
    for(int i = 0; i &lt; modlen; i++) {
      if((t &amp; 1) == 0) {
        t += mod;
        nr += vi;
      }
      t &gt;&gt;= 1;
      vi &lt;&lt;= 1;
    }
  }
  ll reduction(ll t) {
    ll c = t * nr;
    c &amp;= mask;
    c *= mod;
    c += t;
    c &gt;&gt;= modlen;
    if(c &gt;= mod) c -= mod;
    return c;
  }
  // maybe, a * b must not be overflow
  inline ll mul(ll a, ll b) { return reduction(reduction(a * b) * r2); }
  ll pow(ll a, ll b) {
    ll p = reduction(a * r2);
    ll x = reduction(r2);
    while(b) {
      if(b &amp; 1) x = reduction(x * p);
      p = reduction(p * p);
      b &gt;&gt;= 1;
    }
    return reduction(x);
  }
};

/// }}}--- ///

Montgomery&lt;&gt; montgomery;
</code></pre>

<p><span class="lib-title">NTT Library</span></p>

<pre><code>// require math library
/// --- NTT Library {{{ ///
struct NTT {
  ll mod, primitive;
  NTT() {}
  NTT(ll mod, ll primitive) : mod(mod), primitive(primitive) {}
  vector&lt; ll &gt; fft(vector&lt; ll &gt; a, bool inv = 0) {
    int n = a.size();
    int h = 32 - __builtin_clz(n);
    h--;
    // bitの反転
    for(int i = 0; i &lt; n; i++) {
      int j = 0;
      for(int k = 0; k &lt; h; k++) j |= (i &gt;&gt; k &amp; 1) &lt;&lt; (h - 1 - k);
      if(i &lt; j) swap(a[i], a[j]);
    }
    // i : 今考えている多項式の次数 / 2
    for(int i = 1; i &lt; n; i *= 2) {
      ll zeta = modpow(primitive, (mod - 1) / (i * 2), mod);
      if(inv) zeta = modinv(zeta, mod);
      ll tmp = 1;
      // j : 指数
      for(int j = 0; j &lt; i; j++) {
        // k : 何個目の多項式か
        for(int k = 0; k &lt; n; k += i * 2) {
          ll s = a[k + j + 0];
          ll t = a[k + j + i] * tmp % mod;
          a[k + j + 0] = (s + t) % mod;
          a[k + j + i] = (s - t) % mod;
        }
        tmp = tmp * zeta % mod;
      }
    }
    int invn = modinv(n, mod);
    if(inv)
      for(int i = 0; i &lt; n; i++) a[i] = a[i] * invn % mod;
    for(int i = 0; i &lt; n; i++) a[i] = (a[i] + mod) % mod;
    return a;
  }
  template &lt; typename T &gt;
  vector&lt; ll &gt; conv(vector&lt; T &gt; aa, vector&lt; T &gt; bb) {
    int deg = aa.size() + bb.size();
    int n = 1;
    while(n &lt; deg) n &lt;&lt;= 1;
    vector&lt; ll &gt; a(n), b(n);
    for(int i = 0; i &lt; (int) aa.size(); i++) a[i] = aa[i] % mod;
    for(int i = 0; i &lt; (int) bb.size(); i++) b[i] = bb[i] % mod;
    a = fft(a);
    b = fft(b);
    vector&lt; ll &gt; c(n);
    for(int i = 0; i &lt; n; i++) c[i] = a[i] * b[i] % mod;
    return fft(c, 1);
  }
};
/// }}}--- ///

vector&lt; NTT &gt; ntts{
    NTT((1 &lt;&lt; 24) * 73 + 1, 3),
    NTT((1 &lt;&lt; 21) * 3 * 7 * 23 + 1, 5),
    NTT((1 &lt;&lt; 25) * 5 + 1, 3),
    NTT((1 &lt;&lt; 26) * 7 + 1, 3),
    NTT((1 &lt;&lt; 21) * 3 * 3 * 7 * 7 + 1, 5),
};

/// --- Garner Library {{{ ///
ll garner(vector&lt; int &gt; n, vector&lt; int &gt; mods, ll mod) {
  n.emplace_back(0);
  mods.emplace_back(mod);
  vector&lt; ll &gt; coeffs(n.size(), 1); // v_i の係数
  // v_i の項より後ろの項の和,答え mod mods[i]
  vector&lt; ll &gt; constants(n.size(), 0);
  for(size_t i = 0; i &lt; n.size(); i++) {
    // coeffs[i] * v_i + constants[i] == n[i] (mod mods[i]) を解く
    ll v = ll(n[i] - constants[i]) * modinv(coeffs[i], mods[i]) % mods[i];
    if(v &lt; 0) v += mods[i];
    for(size_t j = i + 1; j &lt; n.size(); j++) {
      // coeffs[j] is (mod j)
      (constants[j] += coeffs[j] * v) %= mods[j];
      (coeffs[j] *= mods[i]) %= mods[j];
    }
  }
  return constants.back();
}
/// }}}--- ///

template &lt; class T &gt;
// convolution with NTT {{{
vector&lt; ll &gt; conv(vector&lt; T &gt; a, vector&lt; T &gt; b, int use = 1, ll mod = 1e9 + 7) {
  vector&lt; vector&lt; ll &gt; &gt; cs;
  auto nlist = ntts;
  nlist.resize(use);
  for(auto ntt : nlist) {
    cs.emplace_back(ntt.conv(a, b));
  }
  if(use == 1) return cs[0];
  int n = cs[0].size();
  vector&lt; ll &gt; c(n);
  for(int i = 0; i &lt; n; i++) {
    vector&lt; ll &gt; vals(use), mods(use);
    for(int j = 0; j &lt; use; j++) {
      vals[j] = cs[j][i];
      mods[j] = nlist[j].mod;
    }
    c[i] = garner(vals, mods, mod);
  }
  return c;
}
// }}}
</code></pre>

<p><span class="lib-title">Convex Hull Trick Library</span></p>

<pre><code>// CHT(bool increasing, Compare comp);
// increasing : is query monotonic-increasing ?
// comp : rhs is better
// add(pair&lt;T, T&gt; line) : add deacrinsgly!!
/// --- Convex Hull Trick Library {{{ ///

struct CHT {
  using Line = pair&lt; ll, ll &gt;;
  vector&lt; Line &gt; lines;
  bool increasing;
  function&lt; bool(ll, ll) &gt; comp;
  CHT(bool increasing = false, function&lt; bool(ll, ll) &gt; comp =
                                   [&amp;](ll lhs, ll rhs) { return lhs &gt;= rhs; })
      : increasing(increasing), comp(comp) {}
  // is l2 unnecessary ?
  bool check(Line l1, Line l2, Line l3) {
    return comp((l1.second - l2.second) * (l3.first - l2.first),
                (l3.second - l2.second) * (l1.first - l2.first));
  }
  ll f(int i, ll x) { return lines[i].first * x + lines[i].second; }
  // add decreasingly
  void add(ll a, ll b) { add(Line(a, b)); }
  void add(Line line) {
    while((int) lines.size() &gt;= 2 &amp;&amp;
          check(lines[lines.size() - 2], lines.back(), line))
      lines.pop_back();
    lines.emplace_back(line);
  }
  ll query(ll x) {
    if(increasing) {
      static int head = 0;
      while((int) lines.size() - 1 &gt; head &amp;&amp; comp(f(head, x), f(head + 1, x)))
        head++;
      return f(head, x);
    } else {
      int low = -1, high = lines.size() - 1;
      while(high - low &gt; 1) {
        int mid = (low + high) &gt;&gt; 1;
        (comp(f(mid, x), f(mid + 1, x)) ? low : high) = mid;
      }
      return f(high, x);
    }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Dynamic Convex Hull Trick Library</span></p>

<pre><code>/// --- Dynamic Convex Hull Trick Library {{{ ///

struct DynamicCHT {
  static const ll INF = numeric_limits&lt; ll &gt;::max();
  DynamicCHT() {
    // sentinel
    S.insert({L(INF, 0), L(-INF, 0)});
    C.insert(cp(L(INF, 0), L(-INF, 0)));
  }
  // for debug
  void print() {
#ifdef DEBUG
    cerr &lt;&lt; "S : ";
    for(auto it : S) cerr &lt;&lt; "(" &lt;&lt; it.a &lt;&lt; "," &lt;&lt; it.b &lt;&lt; ")" &lt;&lt; endl;
    cerr &lt;&lt; "C : ";
    for(auto it : C) cerr &lt;&lt; "(" &lt;&lt; it.n &lt;&lt; "," &lt;&lt; it.d &lt;&lt; ")" &lt;&lt; endl;
#endif
  }
  // |ab| &lt; LLONG_MAX/4 ???
  void add(ll a, ll b) {
    const L p(a, b);
    It pos = S.insert(p).first;
    if(check(*it_m1(pos), p, *it_p1(pos))) {
      // 直線(a,b)が不要
      S.erase(pos);
      return;
    }
    C.erase(cp(*it_m1(pos), *it_p1(pos)));
    {
      // 右方向の削除
      It it = it_m1(pos);
      while(it != S.begin() &amp;&amp; check(*it_m1(it), *it, p)) --it;
      C_erase(it, it_m1(pos));
      S.erase(++it, pos);
      pos = S.find(p);
    }
    {
      // 左方向の削除
      It it = it_p1(pos);
      while(it_p1(it) != S.end() &amp;&amp; check(p, *it, *it_p1(it))) ++it;
      C_erase(++pos, it);
      S.erase(pos, it);
      pos = S.find(p);
    }
    C.insert(cp(*it_m1(pos), *pos));
    C.insert(cp(*pos, *it_p1(pos)));
  }
  ll query(ll x) {
    const L &amp;p = (--C.lower_bound(CP(x, 1, L(0, 0))))-&gt;p;
    return p.a * x + p.b;
  }

private:
  template &lt; class T &gt;
  T it_p1(T a) {
    return ++a;
  }
  template &lt; class T &gt;
  T it_m1(T a) {
    return --a;
  }
  struct L {
    ll a, b;
    L(ll a, ll b) : a(a), b(b) {}
    bool operator&lt;(const L &amp;rhs) const {
      return a != rhs.a ? a &gt; rhs.a : b &lt; rhs.b;
    }
  };
  struct CP {
    ll n, d;
    L p;
    CP(ll _n, ll _d, const L &amp;p) : n(_n), d(_d), p(p) {
      if(d &lt; 0) {
        n *= -1;
        d *= -1;
      }
    };
    bool operator&lt;(const CP &amp;rhs) const {
      if(n == INF || rhs.n == -INF) return 0;
      if(n == -INF || rhs.n == INF) return 1;
      return n * rhs.d &lt; rhs.n * d;
    }
  };
  set&lt; L &gt; S;
  set&lt; CP &gt; C;

  typedef set&lt; L &gt;::iterator It;

  void C_erase(It a, It b) {
    for(It it = a; it != b; ++it) C.erase(cp(*it, *it_p1(it)));
  }
  CP cp(const L &amp;p1, const L &amp;p2) {
    if(p1.a == INF) return CP(-INF, 1, p2);
    if(p2.a == -INF) return CP(INF, 1, p2);
    return CP(p1.b - p2.b, p2.a - p1.a, p2);
  }
  bool check(const L &amp;p1, const L &amp;p2, const L &amp;p3) {
    if(p1.a == p2.a &amp;&amp; p1.b &lt;= p2.b) return 1;
    if(p1.a == INF || p3.a == -INF) return 0;
    return (p2.a - p1.a) * (p3.b - p2.b) &gt;= (p2.b - p1.b) * (p3.a - p2.a);
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">XorShift128</span></p>

<pre><code>/// --- XorShift128 {{{ ///
struct XorShift128 {
  using u32 = uint32_t;
  u32 x = 123456789, y = 362436069, z = 521288629, w = 88675123;
  XorShift128(u32 seed = 0) { z ^= seed; }
  u32 operator()() {
    u32 t = x ^ (x &lt;&lt; 11);
    x = y, y = z, z = w;
    return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
  }
};
/// }}}--- ///
</code></pre>

<p><span class="lib-title">AhoCorasick Library</span></p>

<pre><code>// never fail to call build() !!
// constructor()
// add(string)
// match(string, f)           : [left, right], f(int left, int right, int key)
// next(node, char, f): Trie* : f(int len, int key)
// in right-asc -&gt; left-desc order
/// --- AhoCorasick Library {{{ ///

struct AhoCorasick {
  struct Trie {
    unordered_map&lt; char, Trie * &gt; child;
    int id;
    Trie *failure = nullptr;
    Trie *next = nullptr; // next failure that has the word
    int word = -1;
    Trie *add(char c) {
      if(child.count(c)) {
        return child[c];
      } else {
        return child[c] = new Trie;
      }
    }
    Trie *go(char c) {
      if(child.count(c)) {
        return child[c];
      } else {
        if(failure == nullptr) { // only top can come here
          return this;
        } else {
          return failure-&gt;go(c);
        }
      }
    }
  };
  Trie *top = new Trie;
  vector&lt; string &gt; dict;
  void add(string word) {
    Trie *now = top;
    for(size_t i = 0; i &lt; word.size(); i++) {
      now = now-&gt;add(word[i]);
    }
    now-&gt;word = dict.size();
    dict.emplace_back(word);
  }
  void build() {
    queue&lt; Trie * &gt; q;
    q.emplace(top);
    while(q.size()) {
      Trie *now = q.front();
      q.pop();
      for(pair&lt; char, Trie * &gt; ch : now-&gt;child) {
        q.emplace(ch.second);
        Trie *failure = ch.second-&gt;failure =
            now == top ? top : now-&gt;failure-&gt;go(ch.first);
        ch.second-&gt;next = failure-&gt;word &gt;= 0 ? failure : failure-&gt;next;
      }
    }
  }
  Trie *next(Trie *now, char c,
             const function&lt; void(int, int) &gt; &amp;f = [](int, int) {}) {
    now = now-&gt;go(c);
    Trie *tmp = now;
    while(tmp != nullptr &amp;&amp; tmp != top) {
      int word = tmp-&gt;word;
      if(word &gt;= 0) {
        f(dict[word].size(), word);
      }
      tmp = tmp-&gt;next;
    }
    return now;
  }
  void match(string s,
             const function&lt; void(int, int, int) &gt; &amp;f = [](int, int, int) {}) {
    Trie *now = top;
    for(size_t i = 0; i &lt; s.size(); i++) {
      now = now-&gt;go(s[i]);
      Trie *tmp = now;
      while(tmp != nullptr &amp;&amp; tmp != top) {
        int word = tmp-&gt;word;
        if(word &gt;= 0) {
          f(i - dict[word].size() + 1, i, word);
        }
        tmp = tmp-&gt;next;
      }
    }
  }
};

/// }}}--- ///

using Trie = AhoCorasick::Trie;
</code></pre>

<p><span class="lib-title">mp</span></p>

<pre><code>// [i] = size of longest common suffix and prefix in s[0,i-1]
// 瞬間最悪計算量 O(N)
// 均し計算量 O(N)
vector&lt; int &gt; MP(string s) {
  int n = s.size();
  vector&lt; int &gt; A(n + 1);
  A[0] = -1;
  int j = -1;
  for(int i = 0; i &lt; n; i++) {
    while(j &gt;= 0 &amp;&amp; s[i] != s[j]) j = A[j];
    A[i + 1] = ++j;
  }
  return A;
}
</code></pre>

<p><span class="lib-title">kmp</span></p>

<pre><code>// [i] = size of longest common suffix and prefix in s[0,i-1]
// 瞬間最悪計算量 O(log N)
// 均し計算量 O(N)
vector&lt; int &gt; KMP(string s) {
  int n = s.size();
  vector&lt; int &gt; kmp(n + 1), mp(n + 1);
  kmp[0] = mp[0] = -1;
  int j = -1;
  for(int i = 0; i &lt; n; i++) {
    while(j &gt;= 0 &amp;&amp; s[i] != s[j]) j = kmp[j];
    kmp[i + 1] = mp[i + 1] = ++j;
    if(i + 1 &lt; n &amp;&amp; s[i + 1] == s[j]) kmp[i + 1] = kmp[j];
  }
  return mp;
}
</code></pre>

<p><span class="lib-title">cycle</span></p>

<pre><code>// [i] = min cycle length in [0,i]
// 最小周期長
// NOTE : justである必要なし
vector&lt; int &gt; cycle(string s) {
  auto mp = MP(s);
  vector&lt; int &gt; len(s.size());
  for(int i = 0; i &lt; (int) s.size(); i++) len[i] = i + 1 - mp[i + 1];
  return len;
}
</code></pre>

<p><span class="lib-title">LCP Array Library</span></p>

<pre><code>// require SA
/// --- LCP Array Library {{{ ///

template &lt; class S = SA&lt;&gt; &gt;
struct LCP {
  using T = typename S::T;
  const int n;
  const T &amp;s;
  vector&lt; int &gt; lcp;
  int operator[](int i) const { return lcp[i]; }
  LCP(const S &amp;sa) : n(sa.n), s(sa.s), lcp(n - 1) {
    int h = 0;
    for(int i = 0; i &lt; n; i++) {
      if(h) h--;
      if(sa.rnk[i] == 0) continue;
      int j = sa[sa.rnk[i] - 1];
      while(i + h &lt; n &amp;&amp; j + h &lt; n &amp;&amp; s[i + h] == s[j + h]) h++;
      lcp[sa.rnk[i] - 1] = h;
    }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">manacher</span></p>

<pre><code>// [i] = max radius as a palindrome when [i] is center
// NOTE : 偶数長ほしいなら'$'とか挿入してね
vector&lt; int &gt; Manacher(string s) {
  int n = s.size();
  int i = 0, j = 0;
  vector&lt; int &gt; R(n);
  while(i &lt; n) {
    while(i - j &gt;= 0 &amp;&amp; i + j &lt; n &amp;&amp; s[i - j] == s[i + j]) ++j;
    R[i] = j;
    int k = 1;
    while(i - k &gt;= 0 &amp;&amp; R[i - k] &lt; j - k) R[i + k] = R[i - k], ++k;
    i += k, j -= k;
  }
  return R;
}
</code></pre>

<p><span class="lib-title">SA-IS</span></p>

<pre><code>/// --- SA-IS {{{ ///

template &lt; class _T = string, class U = char, int K = 256 &gt;
struct SA {
  using T = _T;
  const int n;
  const T &amp;s;
  vector&lt; int &gt; rnk;
  vector&lt; int &gt; sa;
  int operator[](int i) const { return sa[i]; }
  SA(const string &amp;s) : n(s.size()), s(s), rnk(n) {
    sa_is&lt; T, U &gt;(sa, s + U(0), K); // change if T != string
    sa.erase(begin(sa));
    for(int i = 0; i &lt; n; i++) rnk[sa[i]] = i;
  }
  template &lt; class V = string, class W = char &gt;
  void sa_is(vector&lt; int &gt; &amp;sa, const V &amp;s, int k) {
    int n = s.size();
    vector&lt; int &gt; S(n); // or L
    //
    S.back() = 1;
    for(int i = n - 2; i &gt;= 0; i--) {
      if(s[i] &lt; s[i + 1])
        S[i] = 1;
      else if(s[i] &gt; s[i + 1])
        S[i] = 0;
      else
        S[i] = S[i + 1];
    }
    //
    vector&lt; int &gt; lms;
    for(int i = 0; i &lt; n; i++)
      if(isLMS(S, i)) lms.emplace_back(i);
    auto seed = lms;

    vector&lt; int &gt; _sa;
    inducedSort&lt; V, W &gt;(_sa, s, k, S, seed);

    sa.resize(0);
    for(auto el : _sa)
      if(isLMS(S, el)) sa.emplace_back(el);

    vector&lt; int &gt; nums(n, -1);
    int num = 0;
    nums[sa[0]] = 0;

    for(int x = 0; x &lt; (int) sa.size() - 1; x++) {
      int i = sa[x], j = sa[x + 1];
      int diff = 0;
      for(int d = 0; d &lt; n; d++) {
        if(s[i + d] != s[j + d] || isLMS(S, i + d) != isLMS(S, j + d)) {
          diff = 1;
          break;
        } else if(d &amp;&amp; (isLMS(S, i + d) || isLMS(S, j + d)))
          break;
      }
      if(diff) num++;
      nums[j] = num;
    }
    auto _nums = nums;
    nums.resize(0);
    for(int el : _nums)
      if(el != -1) nums.emplace_back(el);

    if(num + 1 &lt; (int) nums.size()) {
      sa_is&lt; vector&lt; int &gt;, int &gt;(seed, nums, num + 1);
    } else {
      seed.resize(num + 1);
      for(int i = 0; i &lt; num + 1; i++) seed[nums[i]] = i;
    }

    for(int &amp;el : seed) el = lms[el];

    inducedSort&lt; V, W &gt;(sa, s, k, S, seed);
  }
  template &lt; class V = string, class W = char &gt;
  void inducedSort(vector&lt; int &gt; &amp;sa, const V &amp;s, int k, const vector&lt; int &gt; &amp;S,
                   const vector&lt; int &gt; &amp;lms) {
    int n = s.size();
    sa.resize(n), sa.assign(n, -1);
    vector&lt; int &gt; bin(k + 1, 0);
    for(W ch : s) bin[ch + 1]++;
    int sum = 0;
    for(int &amp;el : bin) el = sum += el;
    // step 1
    vector&lt; int &gt; count(k);
    for(auto it = rbegin(lms); it != rend(lms); ++it) {
      int i = *it;
      W ch = s[i];
      sa[bin[ch + 1] - 1 - count[ch]] = i;
      count[ch]++;
    }
    // step 2
    count.assign(k, 0);
    for(int i : sa) {
      if(i == -1 || i == 0) continue;
      if(S[i - 1]) continue;
      W ch = s[i - 1];
      sa[bin[ch] + count[ch]] = i - 1;
      count[ch]++;
    }
    // step 3
    count.assign(k, 0);
    for(auto it = rbegin(sa); it != rend(sa); ++it) {
      int i = *it;
      if(i == -1 || i == 0) continue;
      if(!S[i - 1]) continue;
      W ch = s[i - 1];
      sa[bin[ch + 1] - 1 - count[ch]] = i - 1;
      count[ch]++;
    }
  }
  inline bool isLMS(const vector&lt; int &gt; &amp;S, int i) {
    return i &gt; 0 &amp;&amp; !S[i - 1] &amp;&amp; S[i];
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">Suffix Array with Manber &amp; Myers</span></p>

<pre><code>/// --- Suffix Array with Manber &amp; Myers {{{ ///

template &lt; class _T = string &gt;
struct SA {
  using T = _T;
  const int n;
  const T &amp;s;
  vector&lt; int &gt; rnk;
  vector&lt; int &gt; sa;
  int operator[](int i) const { return sa[i]; }
  SA(const T &amp;s) : n(s.size()), s(s), rnk(n), sa(n) {
    iota(begin(sa), end(sa), 0);
    sort(begin(sa), end(sa), [&amp;](int a, int b) { return s[a] &lt; s[b]; });
    for(int i = 0; i &lt; n; i++) rnk[i] = s[i];
    for(int i = 1; i &lt; n; i &lt;&lt;= 1) {
      auto comp = [&amp;](int a, int b) {
        if(rnk[a] != rnk[b]) return rnk[a] &lt; rnk[b];
        a = a + i &lt; n ? rnk[a + i] : -1;
        b = b + i &lt; n ? rnk[b + i] : -1;
        return a &lt; b;
      };
      sort(begin(sa), end(sa), comp);
      auto tmp = rnk;
      tmp[sa[0]] = 0;
      for(int j = 1; j &lt; n; j++)
        tmp[sa[j]] = tmp[sa[j - 1]] + comp(sa[j - 1], sa[j]); ///
      rnk = tmp;
    }
  }
};

/// }}}--- ///
</code></pre>

<p><span class="lib-title">zalgorithm</span></p>

<pre><code>// size of longest common prefix between s and s[i, -1]
vector&lt; int &gt; Zalgorithm(string s) {
  int n = s.size();
  vector&lt; int &gt; Z(n);
  Z[0] = n;
  int i = 1, j = 0;
  while(i &lt; n) {
    while(i + j &lt; n &amp;&amp; s[j] == s[i + j]) ++j;
    Z[i] = j;
    if(j == 0) {
      ++i;
      continue;
    }
    int k = 1;
    while(i + k &lt; n &amp;&amp; Z[k] &lt; j - k) Z[i + k] = Z[k], ++k;
    i += k, j -= k;
  }
  return Z;
}
</code></pre>

      </div>
    </main>
  </body>

</html>
